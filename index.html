<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Dungeon Enhanced</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
        }
        #micButton {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #222;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        #micButton:active {
            background: #444;
        }
        .listening {
            background: #004400 !important;
        }
        .start-button {
            background: #000044 !important;
        }
        #textDisplay {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="textDisplay" role="status" aria-live="polite"></div>
    <button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button - Tap to speak"></button>

    <script>
        const micButton = document.getElementById('micButton');
        const textDisplay = document.getElementById('textDisplay');

        function displayText(text) {
            textDisplay.innerHTML = text;
        }

        let browserSupport = {
            speechSynthesis: false,
            speechRecognition: false,
            https: false
        };
        function checkBrowserSupport() {
            browserSupport.https = window.location.protocol === 'https:' ||
                window.location.hostname === 'localhost';
            browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
            browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
        }

        const game = {
            player: {
                class: '',
                level: 1,
                experience: 0,
                experienceToNext: 100,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                gold: 25,
                inventory: [],
                equippedRings: [],
                learnedAbilities: [],
                equippedAmulet: '',
                position: { x: 5, y: 5 },
                baseAttack: 15,
                defense: 0,
                weapon: '',
                armor: ''
            },
            dungeon: {
                grid: {},
                size: 10,
                secretRoom: null,
                hasSecretRoom: false,
                currentLevel: 1
            },
            currentRoom: null,
            combat: null,
            listening: false,
            started: false,
            needsClass: true,
            initialized: false,
            phase: 'init'
        };
        const classes = {
            warrior: {
                name: 'Warrior',
                health: 120,
                maxHealth: 120,
                mana: 30,
                maxMana: 30,
                gold: 50,
                items: ['Steel Sword', 'Health Potion', 'Health Potion', 'Chainmail'],
                special: { name: 'Power Strike', damage: 40, cost: 15, type: 'damage' }
            },
            mage: {
                name: 'Mage',
                health: 80,
                maxHealth: 80,
                mana: 100,
                maxMana: 100,
                gold: 75,
                items: ['Mystic Staff', 'Mana Potion', 'Health Potion', 'Enchanted Robes'],
                special: { name: 'Fireball', damage: 30, cost: 20, type: 'damage' }
            },
            rogue: {
                name: 'Rogue',
                health: 100,
                maxHealth: 100,
                mana: 60,
                maxMana: 60,
                gold: 100,
                items: ['Shadow Daggers', 'Lockpicks', 'Health Potion', 'Shadow Leather'],
                special: { name: 'Backstab', damage: 35, cost: 25, type: 'damage' }
            }
        };
        const equipment = {
            weapons: [
                { name: 'Steel Sword', attack: 8, class: 'warrior', value: 100 },
                { name: 'Mystic Staff', attack: 10, class: 'mage', value: 150 },
                { name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120 }
            ],
            armor: [
                { name: 'Chainmail', defense: 8, class: 'warrior', value: 100 },
                { name: 'Enchanted Robes', defense: 5, class: 'mage', value: 120 },
                { name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110 }
            ]
        };
        const abilities = [
            { name: 'Heal', damage: 0, healing: 40, cost: 25, type: 'heal', description: 'Restore 40 health using mana', class: 'mage' },
            { name: 'Shield Bash', damage: 30, cost: 20, type: 'stun', description: 'Stun enemy for one turn', class: 'warrior' },
            { name: 'Poison Blade', damage: 20, cost: 20, type: 'poison', duration: 3, description: 'Poison damages 5 per turn for 3 turns', class: 'rogue' }
        ];

        const amulets = [
            { name: 'Amulet of Vitality', effect: '+15 Max Health', stat: 'maxHealth', value: 15 },
            { name: 'Amulet of Mana', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Amulet of Experience', effect: '+20% Experience Gain', stat: 'expGain', value: 1.2 }
        ];
        const roomTypes = {
            entrance: {
                descriptions: [
                    'the grand entrance hall. Torches flicker on ancient stone walls.',
                    'the entrance chamber. A faded tapestry hangs on the north wall.',
                    'the starting hall. Cobwebs drape from vaulted ceilings above.'
                ],
                hasEnemy: false
            },
            empty: {
                descriptions: [
                    'an abandoned barracks. Rusty weapons litter the floor.',
                    'a collapsed library. Torn pages scatter at your feet.',
                    'a crumbling shrine. A broken altar stands in the center.',
                    'a forgotten armory. Empty weapon racks line the walls.',
                    'a dusty workshop. Ancient tools hang from hooks.',
                    'a meditation chamber. Stone benches circle a dry fountain.',
                    'an old prison cell. Iron bars have rusted through.',
                    'a guard post. A skeleton sits slumped in a chair.'
                ],
                hasEnemy: false
            },
            treasure: {
                descriptions: [
                    'a glittering treasure vault. Gold coins reflect torchlight.',
                    'a dragon\'s hoard chamber. Piles of jewels gleam in the darkness.',
                    'a royal treasury. Ancient chests overflow with riches.',
                    'a pirate\'s cache. Stolen goods fill every corner.',
                    'a wizard\'s vault. Magical artifacts pulse with energy.'
                ],
                hasEnemy: false
            },
            enemy: {
                descriptions: [
                    'a dark chamber. You sense hostile eyes watching you.',
                    'a blood-stained arena. Old battle scars mark the floor.',
                    'a shadowy lair. Something growls in the darkness.',
                    'a monster\'s den. Bones crunch beneath your feet.',
                    'a cursed chamber. An evil presence fills the air.'
                ],
                hasEnemy: true
            },
            boss: {
                descriptions: [
                    'the throne room of darkness. A massive beast awaits on a stone throne.',
                    'the dragon\'s lair. Heat radiates from the enormous creature before you.',
                    'the demon king\'s chamber. Dark energy swirls around your foe.'
                ],
                hasEnemy: true
            },
            trap: {
                descriptions: [
                    'a trapped corridor. Pressure plates cover the floor.',
                    'a spike-filled chamber. Deadly traps line the walls.',
                    'a poison gas room. Strange vapors seep from cracks.'
                ],
                hasEnemy: false
            },
            stairs: {
                descriptions: [
                    'a spiral stairwell. Dark stone steps descend into deeper darkness.',
                    'a grand staircase. Ancient carvings decorate the descent.',
                    'a hidden passage. Secret stairs lead to the next level.'
                ],
                hasEnemy: false
            },
            fountain: {
                descriptions: [
                    'a magical fountain room. Crystal clear water bubbles from an enchanted spring.',
                    'an ancient healing shrine. A mystical fountain glows with restorative power.'
                ],
                hasEnemy: false
            },
            crypt: {
                descriptions: [
                    'a dusty crypt. Stone sarcophagi line the walls.',
                    'an ancient burial chamber. Skeletal remains rest in alcoves.',
                    'a forgotten tomb. Hieroglyphs cover every surface.'
                ],
                hasEnemy: false
            }
        };
        const enemies = {
            goblin: { name: 'Goblin', health: 30, damage: 8, gold: 5, exp: 15, fleeChance: 0.8 },
            skeleton: { name: 'Skeleton', health: 40, damage: 10, gold: 8, exp: 20, fleeChance: 0.7 },
            orc: { name: 'Orc', health: 60, damage: 15, gold: 12, exp: 30, fleeChance: 0.5 },
            wraith: { name: 'Wraith', health: 50, damage: 18, gold: 15, exp: 35, fleeChance: 0.6 },
            troll: { name: 'Troll', health: 80, damage: 20, gold: 20, exp: 45, fleeChance: 0.4 },
            dragon: { name: 'Dragon', health: 150, damage: 30, gold: 50, exp: 100, fleeChance: 0.1 }
        };
        const treasures = [
            { name: 'Sapphire Gem', value: 50 },
            { name: 'Ruby Gem', value: 75 },
            { name: 'Diamond', value: 100 },
            { name: 'Emerald', value: 60 },
            { name: 'Ancient Coin Collection', value: 40 },
            { name: 'Golden Chalice', value: 80 },
            { name: 'Silver Crown', value: 90 },
            { name: 'Amulet of Vitality', value: 120 } 
        ];
        const rings = [
            { name: 'Ring of Minor Health', effect: '+10 Max Health', stat: 'maxHealth', value: 10 },
            { name: 'Ring of Minor Mana', effect: '+10 Max Mana', stat: 'maxMana', value: 10 },
            { name: 'Ring of Protection', effect: '+5 Max Health', stat: 'maxHealth', value: 5 },
            { name: 'Ring of Strength', effect: '+2 Attack Damage', stat: 'attack', value: 2 },
            { name: 'Ring of Wisdom', effect: '+5 Max Mana', stat: 'maxMana', value: 5 }
        ];
        function speak(text, callback) {
            displayText(text);
            if (!browserSupport.speechSynthesis) {
                if (callback) setTimeout(callback, 2000);
                return;
            }
            try {
                speechSynthesis.cancel();
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g, ''));
                    utterance.rate = 0.9;
                    if (callback) {
                        utterance.onend = callback;
                        utterance.onerror = callback;
                    }
                    speechSynthesis.speak(utterance);
                }, 100);
            } catch (error) {
                if (callback) setTimeout(callback, 2000);
            }
        }

        function speakSequence(messages, callback) {
            if (messages.length === 0) {
                if (callback) callback();
                return;
            }
            const [first, ...rest] = messages;
            speak(first, () => {
                if (rest.length > 0) {
                    setTimeout(() => speakSequence(rest, callback), 500);
                } else if (callback) {
                    callback();
                }
            });
        }

        let recognition = null;
        function startListening() {
            if (!browserSupport.speechRecognition || !browserSupport.https) {
                speak('Voice recognition requires HTTPS and a compatible browser like Chrome or Edge.');
                return;
            }
            if (game.listening) { stopListening(); return;
            }
            try {
                const Recognition = window.webkitSpeechRecognition ||
                    window.SpeechRecognition;
                recognition = new Recognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.onstart = () => {
                    game.listening = true;
                    micButton.classList.add('listening');
                };
                recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase().trim();
                    displayText(`You said: "${command}"`);
                    stopListening();
                    setTimeout(() => processCommand(command), 500);
                };
                recognition.onerror = (event) => {
                    stopListening();
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        speak('Voice error. Try again.');
                    }
                };
                recognition.onend = () => stopListening();
                recognition.start();
            } catch (error) {
                speak('Failed to start voice recognition.');
                stopListening();
            }
        }

        function stopListening() {
            game.listening = false;
            micButton.classList.remove('listening');
            if (recognition) {
                try { recognition.stop();
                } catch (e) {}
                recognition = null;
            }
        }

        function saveGame() {
            const saveData = {
                player: game.player,
                dungeon: {
                    grid: game.dungeon.grid,
                    currentLevel: game.dungeon.currentLevel,
                    size: game.dungeon.size,
                    hasSecretRoom: game.dungeon.hasSecretRoom
                },
                currentRoom: game.currentRoom
            };
            const saveStr = JSON.stringify(saveData);
            const pin = Math.floor(1000 + Math.random() * 9000).toString();
            localStorage.setItem(`echoDungeon_${pin}`, saveStr);
            const spokenPin = pin.split('').join(' ');
            speak(`Game saved! Your save PIN is ${spokenPin}. Say "load game" then "code ${spokenPin}" to load.`);
        }

        function loadGame(pin) {
            try {
                const saveStr = localStorage.getItem(`echoDungeon_${pin}`);
                if (!saveStr) {
                    speak(`No game found for PIN ${pin.split('').join(' ')}. Try another PIN or start a new game.`);
                    return;
                }
                const saveData = JSON.parse(saveStr);
                game.player = saveData.player;
                game.dungeon.grid = saveData.dungeon.grid;
                game.dungeon.currentLevel = saveData.dungeon.currentLevel;
                game.dungeon.size = saveData.dungeon.size;
                game.dungeon.hasSecretRoom = saveData.dungeon.hasSecretRoom;
                game.currentRoom = saveData.currentRoom;
                game.initialized = true;
                game.started = true;
                game.needsClass = false;
                game.phase = 'exploration';
                micButton.classList.remove('start-button');
                speak(`Game loaded! You are a level ${game.player.level} ${classes[game.player.class].name} on Dungeon Level ${game.dungeon.currentLevel}.`, () => {
                    describeRoom();
                });
            } catch (e) {
                speak('Error loading game. The PIN may be incorrect.');
            }
        }

        function initializeGame() {
            game.initialized = true;
            micButton.classList.remove('start-button');
            speak("Welcome to Echo Dungeon Enhanced! Say 'load game' and provide your save PIN, or choose your class: warrior, mage, or rogue.");
        }

        function handleClick() {
            if (!game.initialized) {
                initializeGame();
            } else {
                startListening();
            }
        }

        function processCommand(command) {
            if (command.includes('save game') || command.includes('save')) {
                saveGame();
                return;
            }
            if (command.includes('load game') || command.includes('load')) {
                speak('Please say your save PIN after the word "code".');
                game.phase = 'loading';
                return;
            }
            if (command.includes('code ') && game.phase === 'loading') {
                const pin = command.split('code ')[1].trim().replace(/\s/g, '');
                loadGame(pin);
                return;
            }
            if (game.needsClass) {
                if (command.includes('warrior') || command.includes('fighter')) selectClass('warrior');
                else if (command.includes('mage') || command.includes('wizard')) selectClass('mage');
                else if (command.includes('rogue') || command.includes('thief')) selectClass('rogue');
                else speak('Please say warrior, mage, or rogue.');
                return;
            }
            if (game.combat) {
                if (command.includes('attack') || command.includes('fight')) playerAttack();
                else if (command.includes('defend') || command.includes('block') || command.includes('guard')) playerDefend();
                else if (command.includes('special') || command.includes('ability')) playerSpecial();
                else if (command.includes('use ability') || (game.player.class === 'mage' && command.includes('cast'))) castAbility(command);
                else if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) processPotionCommand(command);
                else if (command.includes('flee') || command.includes('run') || command.includes('escape')) attemptFlee();
                else speak('Say attack, defend, special, use ability, use potion, or flee.');
                return;
            }
            
            // --- HIGH PRIORITY EXPLORATION ACTIONS (Force return to prevent fall-through) ---

            // 1. READ BOOK (Must precede generic 'heal' and 'use' logic)
            if (command.includes('read book') || command.includes('read') || command.includes('learn')) {
                readBook(command);
                return;
            }

            // 2. EQUIP RING (Must precede generic 'equip/wear' and 'heal' logic)
            if ((command.includes('wear ring') || command.includes('equip ring') || command.includes('put on ring')) || 
                (command.includes('ring') && (command.includes('wear') || command.includes('equip') || command.includes('health') || command.includes('mana')))) {
                equipRing(command);
                return;
            }

            // 3. EQUIP AMULET (Must precede generic 'equip/wear')
            if ((command.includes('equip amulet') || command.includes('wear amulet')) || 
                (command.includes('amulet') && (command.includes('wear') || command.includes('equip')))) {
                equipAmulet(command);
                return;
            }

            // 4. POTION/HEAL/USE (Generic consumable action)
            if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) {
                processPotionCommand(command);
                return;
            }
            
            // 5. EQUIP GENERAL ITEM (Weapon/Armor)
            if (command.includes('equip') || command.includes('wear')) {
                equipItem(command);
                return;
            }

            // 6. LOCKPICKS
            if (command.includes('use lockpicks') || command.includes('lockpick')) {
                useLockpicks();
                return;
            }
            
            // --- STANDARD EXPLORATION ACTIONS (Else-if chain is fine) ---
            if (command.includes('status') || command.includes('stats') || command.includes('check')) characterStatus();
            else if (command.includes('inventory') || command.includes('items') || command.includes('bag')) listInventory();
            else if (command.includes('commands') || command.includes('what can i')) listCommands();
            else if (command.includes('hint') || command.includes('help me')) giveHint();
            else if (command.includes('north') || command.includes('forward')) move('north');
            else if (command.includes('south') || command.includes('back')) move('south');
            else if (command.includes('east') || command.includes('right')) move('east');
            else if (command.includes('west') || command.includes('left')) move('west');
            else if (command.includes('meditate') || command.includes('rest')) meditate();
            else if (command.includes('look') || command.includes('around') || command.includes('where')) describeRoom();
            else if (command.includes('search') || command.includes('examine')) searchRoom();
            else if (command.includes('open chest') || command.includes('chest') || command.includes('loot')) openChest();
            else if (command.includes('fountain') || command.includes('drink water')) useFountain();
            else if (command.includes('stairs') || command.includes('go down') || command.includes('descend')) useStairs();
            else if (command.includes('help')) showHelp();
            else speak('Unknown command. Say help for options.');
        }

        function gainExperience(exp) {
            let actualExp = exp;
            // FIX: Ensure amulets constant is accessible and check for the correct amulet name
            const expAmulet = amulets.find(a => a.name === 'Amulet of Experience');
            if (game.player.equippedAmulet === expAmulet.name) {
                actualExp = Math.floor(exp * expAmulet.value);
                // Report bonus if combat just ended
                if (!game.combat) {
                    speak(`Your Amulet of Experience grants you a bonus: total experience gained is ${actualExp}.`);
                }
            }
            game.player.experience += actualExp;
            if (game.player.experience >= game.player.experienceToNext) {
                levelUp();
            }
        }

        function levelUp() {
            game.player.level++;
            game.player.experience -= game.player.experienceToNext;
            game.player.experienceToNext = Math.floor(game.player.experienceToNext * 1.5);
            const healthGain = 20;
            const manaGain = 10;
            game.player.maxHealth += healthGain;
            game.player.health = game.player.maxHealth;
            game.player.maxMana += manaGain;
            game.player.mana = game.player.maxMana;
            speakSequence([
                `Level up! You are now level ${game.player.level}!`,
                `Max health increased by ${healthGain}!`,
                `Max mana increased by ${manaGain}!`,
                `Fully healed and restored!`
            ]);
        }

        function equipRing(command) {
            const ringName = command.includes('minor health') || command.includes('health ring') || (command.includes('health') && !command.includes('mana')) ? 'Ring of Minor Health' :
                             command.includes('minor mana') || command.includes('mana ring') || (command.includes('mana') && !command.includes('health')) ? 'Ring of Minor Mana' :
                             command.includes('protection') ? 'Ring of Protection' :
                             command.includes('strength') ? 'Ring of Strength' :
                             command.includes('wisdom') ? 'Ring of Wisdom' : null;
                             
            if (!ringName) {
                const availableRings = game.player.inventory.filter(item => rings.some(r => r.name === item));
                if (availableRings.length > 0) {
                    speak(`You have: ${availableRings.join(', ')}. Say which one to equip, like 'wear health ring'.`);
                } else {
                    speak('You have no rings. Find them in treasure chests or by searching rooms.');
                }
                return;
            }
            const ringIndex = game.player.inventory.findIndex(item => item === ringName);
            if (ringIndex === -1) {
                speak(`You do not have a ${ringName}.`);
                return;
            }
            if (game.player.equippedRings.includes(ringName)) {
                speak(`You are already wearing the ${ringName}.`);
                return;
            }
            const ringData = rings.find(r => r.name === ringName);
            if (!ringData) {
                speak(`Error: Ring data not found.`);
                return;
            }
            game.player.inventory.splice(ringIndex, 1);
            game.player.equippedRings.push(ringName);
            if (ringData.stat === 'maxHealth') {
                game.player.maxHealth += ringData.value;
                game.player.health += ringData.value;
                speak(`You equip the ${ringName}. Your max health increased by ${ringData.value}!`);
            } else if (ringData.stat === 'maxMana') {
                game.player.maxMana += ringData.value;
                game.player.mana += ringData.value;
                speak(`You equip the ${ringName}. Your max mana increased by ${ringData.value}!`);
            } else if (ringData.stat === 'attack') {
                speak(`You equip the ${ringName}. Your attacks are now stronger!`);
            }
        }

        function equipAmulet(command) {
            // Updated amulet search to be more robust
            const availableAmuletsInInv = game.player.inventory.filter(item => amulets.some(a => a.name === item));
            let amuletName = null;
            
            for (const item of availableAmuletsInInv) {
                if (command.includes(item.toLowerCase().replace(/amulet of /g, '').trim())) {
                    amuletName = item;
                    break;
                }
            }

            if (!amuletName) {
                if (availableAmuletsInInv.length > 0) {
                    speak(`You have: ${availableAmuletsInInv.join(', ')}. Say which one to equip, like 'equip amulet vitality'.`);
                } else {
                    speak('You have no amulets. Find them in treasure chests or by searching rooms.');
                }
                return;
            }
            const amuletIndex = game.player.inventory.findIndex(item => item === amuletName);
            
            if (game.player.equippedAmulet === amuletName) {
                speak(`You are already wearing the ${amuletName}.`);
                return;
            }
            
            const amuletData = amulets.find(a => a.name === amuletName);
            if (!amuletData) {
                speak(`Error: Amulet data not found.`);
                return;
            }
            
            // Unequip old amulet if one exists
            if (game.player.equippedAmulet) {
                const oldAmuletData = amulets.find(a => a.name === game.player.equippedAmulet);
                if (oldAmuletData) {
                    // Revert old amulet stats
                    if (oldAmuletData.stat === 'maxHealth') {
                        game.player.maxHealth -= oldAmuletData.value;
                        game.player.health = Math.min(game.player.health, game.player.maxHealth);
                    } else if (oldAmuletData.stat === 'maxMana') {
                        game.player.maxMana -= oldAmuletData.value;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                    // Put old amulet back in inventory
                    game.player.inventory.push(game.player.equippedAmulet);
                }
            }
            
            // Equip new amulet
            game.player.inventory.splice(amuletIndex, 1);
            game.player.equippedAmulet = amuletName;

            // Apply new amulet stats
            if (amuletData.stat === 'maxHealth') {
                game.player.maxHealth += amuletData.value;
                game.player.health += amuletData.value;
                speak(`You equip the ${amuletName}. Your max health increased by ${amuletData.value}!`);
            } else if (amuletData.stat === 'maxMana') {
                game.player.maxMana += amuletData.value;
                game.player.mana += amuletData.value;
                speak(`You equip the ${amuletName}. Your max mana increased by ${amuletData.value}!`);
            } else if (amuletData.stat === 'expGain') {
                speak(`You equip the ${amuletName}. You now gain 20% more experience!`);
            }
        }
        function equipItem(command) {
            const itemName = equipment.weapons.concat(equipment.armor).find(item => command.includes(item.name.toLowerCase()))?.name;
            if (!itemName) {
                const items = game.player.inventory.filter(item => equipment.weapons.some(w => w.name === item) || equipment.armor.some(a => a.name === item));
                if (items.length > 0) {
                    speak(`You have: ${items.join(', ')}. Say "equip <item name>".`);
                } else {
                    speak('You have no equipment to equip.');
                }
                return;
            }
            const itemIndex = game.player.inventory.findIndex(item => item === itemName);
            if (itemIndex === -1) {
                speak(`You do not have a ${itemName}.`);
                return;
            }
            const weapon = equipment.weapons.find(w => w.name === itemName);
            const armor = equipment.armor.find(a => a.name === itemName);
            if (weapon && weapon.class !== game.player.class) {
                speak(`Only a ${weapon.class} can equip ${itemName}.`);
                return;
            }
            if (armor && armor.class !== game.player.class) {
                speak(`Only a ${armor.class} can equip ${itemName}.`);
                return;
            }
            game.player.inventory.splice(itemIndex, 1);
            if (weapon) {
                game.player.weapon = itemName;
                game.player.baseAttack = weapon.attack;
                speak(`You equip the ${itemName}. Your attacks are now stronger!`);
            } else if (armor) {
                game.player.armor = itemName;
                game.player.defense = armor.defense;
                speak(`You equip the ${itemName}. Your defense is improved!`);
            }
        }

        function readBook(command) {
            // FIX: Search for the book name in inventory first and use stricter command matching.
            let bookName = null;
            for (const ability of abilities) {
                const abilityLower = ability.name.toLowerCase();
                // Check for 'book of <ability>', '<ability> book', or just the ability name if 'read' is present
                if ((command.includes('book of ' + abilityLower) || 
                     command.includes(abilityLower + ' book') ||
                     (command.includes('read') && command.includes(abilityLower))) &&
                     game.player.inventory.includes(ability.name) // MUST be in inventory
                   ) {
                    bookName = ability.name;
                    break;
                }
            }
            
            if (!bookName) {
                const books = game.player.inventory.filter(item => abilities.some(a => a.name === item));
                if (books.length > 0) {
                    speak(`You have these books: ${books.join(', ')}. Say "read book of <ability name>" to learn one.`);
                } else {
                    speak('You have no ability books. Find them in chests or secret rooms.');
                }
                return;
            }
            
            const bookIndex = game.player.inventory.findIndex(item => item === bookName);
            
            if (game.player.learnedAbilities.some(a => a.name === bookName)) {
                speak(`You already know ${bookName}.`);
                return;
            }
            
            const ability = abilities.find(a => a.name === bookName);
            if (ability.class !== game.player.class) {
                speak(`Only a ${ability.class} can learn ${bookName}.`);
                return;
            }
            
            game.player.inventory.splice(bookIndex, 1);
            game.player.learnedAbilities.push(ability);
            speak(`You learn ${bookName}! ${ability.description}. Say "use ability ${bookName}" in combat.`);
        }

        function castAbility(command) {
            if (!game.combat) {
                speak('You can only use abilities in combat.');
                return;
            }
            const abilityName = game.player.learnedAbilities.find(a => command.includes(a.name.toLowerCase()))?.name;
            if (!abilityName) {
                if (game.player.learnedAbilities.length > 0) {
                    speak(`You know: ${game.player.learnedAbilities.map(a => a.name).join(', ')}. Say "use ability <ability name>".`);
                } else {
                    speak('You have not learned any abilities.');
                }
                return;
            }
            const ability = game.player.learnedAbilities.find(a => a.name === abilityName);
            if (game.player.mana < ability.cost) {
                speak(`Not enough mana. You need ${ability.cost}.`);
                return;
            }
            game.player.mana -= ability.cost;
            let actionVerb = game.player.class === 'mage' ? 'cast' : 'execute';
            if (ability.type === 'heal') {
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + ability.healing);
                const actualHeal = game.player.health - oldHealth;
                speak(`You ${actionVerb} ${ability.name} and restore ${actualHeal} health!`, () => {
                    setTimeout(() => enemyTurn(), 1000);
                });
            } else if (ability.type === 'stun') {
                game.combat.enemy.stunned = true;
                speak(`You ${actionVerb} ${ability.name}, stunning the ${game.combat.enemy.name}!`, () => {
                    setTimeout(() => enemyTurn(), 1000);
                });
            } else if (ability.type === 'poison') {
                game.combat.enemy.poisoned = { damage: 5, duration: ability.duration };
                speak(`You ${actionVerb} ${ability.name}, poisoning the ${game.combat.enemy.name}!`, () => {
                    setTimeout(() => enemyTurn(), 1000);
                });
            }
        }

        function useLockpicks() {
            if (game.player.class !== 'rogue') {
                speak('Only a rogue can use lockpicks.');
                return;
            }
            if (game.player.inventory.indexOf('Lockpicks') === -1) {
                speak('You have no lockpicks.');
                return;
            }
            if (game.currentRoom.type === 'trap' && !game.currentRoom.visited) {
                game.currentRoom.visited = true;
                speak('You use your lockpicks to disarm the trap safely!');
            } else if (game.currentRoom.hasChest && !game.currentRoom.searched) {
                game.player.inventory.splice(game.player.inventory.indexOf('Lockpicks'), 1);
                game.player.gold += 50;
                speak('You use your lockpicks to unlock a hidden compartment in the chest, finding 50 extra gold!');
            } else {
                speak('No traps or chests to use lockpicks on.');
            }
        }

        function useStairs() {
            if (game.currentRoom.type !== 'stairs') {
                speak('There are no stairs here.');
                return;
            }
            const bossRoom = game.dungeon.grid[`${game.dungeon.size - 1},${game.dungeon.size - 1}`];
            if (bossRoom.enemy && bossRoom.enemy.health > 0) {
                speak('You must defeat the dragon in the boss room before descending.');
                return;
            }
            game.dungeon.currentLevel++;
            generateDungeon();
            speak(`You descend to Dungeon Level ${game.dungeon.currentLevel}. The air grows colder and more dangerous.`, () => {
                describeRoom();
            });
        }

        function useFountain() {
            if (game.currentRoom.type !== 'fountain') {
                speak('There is no fountain here.');
                return;
            }
            if (game.currentRoom.fountainUsed) {
                speak('The fountain has run dry. Its magic is spent.');
                return;
            }
            game.currentRoom.fountainUsed = true;
            game.player.health = game.player.maxHealth;
            game.player.mana = game.player.maxMana;
            speak('You drink from the magical fountain. You are fully healed and restored!');
        }

        function selectClass(className) {
            const classData = classes[className];
            game.player.class = className;
            game.player.level = 1; // Ensure level starts at 1
            game.player.experience = 0;
            game.player.experienceToNext = 100;
            game.player.health = classData.health;
            game.player.maxHealth = classData.maxHealth;
            game.player.mana = classData.mana;
            game.player.maxMana = classData.maxMana;
            game.player.gold = classData.gold;
            game.player.inventory = [...classData.items];
            game.player.equippedRings = [];
            game.player.learnedAbilities = [];
            game.player.equippedAmulet = '';
            game.player.weapon = classData.items.find(item => equipment.weapons.some(w => w.name === item)) || '';
            game.player.armor = classData.items.find(item => equipment.armor.some(a => a.name === item)) || '';
            game.player.baseAttack = equipment.weapons.find(w => w.name === game.player.weapon)?.attack || 15;
            game.player.defense = equipment.armor.find(a => a.name === game.player.armor)?.defense || 0;
            game.needsClass = false;
            game.started = true;
            game.phase = 'exploration';
            generateDungeon();
            speakSequence([
                `You are now a ${classData.name}.`,
                `Health: ${classData.health}.`,
                `Mana: ${classData.mana}.`,
                `Starting gold: ${classData.gold}.`,
                `Equipped: ${game.player.weapon || 'fists'} and ${game.player.armor || 'none'}.`,
                `Your adventure begins!`
            ], () => {
                setTimeout(() => describeRoom(), 1000);
            });
        }

        function getRandomDescription(roomType) {
            const descriptions = roomTypes[roomType].descriptions;
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function generateDungeon() {
            const size = game.dungeon.size;
            game.dungeon.grid = {};
            const centerX = 5;
            const centerY = 5;
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    const key = `${x},${y}`;
                    const distanceX = Math.abs(x - centerX);
                    const distanceY = Math.abs(y - centerY);
                    const distanceFromCenter = distanceX + distanceY;
                    let roomData = { visited: false, searched: false, hasChest: false, fountainUsed: false };
                    if (x === centerX && y === centerY) {
                        game.dungeon.grid[key] = { type: 'entrance', description: getRandomDescription('entrance'), ...roomData };
                    } else if (x === size - 1 && y === size - 1) {
                        game.dungeon.grid[key] = { type: 'boss', description: getRandomDescription('boss'), ...roomData, hasChest: true, enemy: { ...enemies.dragon } };
                    } else if (x === size - 1 && y === size - 2) {
                        game.dungeon.grid[key] = { type: 'stairs', description: getRandomDescription('stairs'), ...roomData };
                    } else {
                        let roomType = null;
                        let enemyType = null;
                        const roll = Math.random();
                        if (distanceFromCenter >= 7) {
                            if (roll < 0.5) {
                                roomType = 'enemy';
                                enemyType = Math.random() < 0.5 ?
                                    'troll' : 'wraith';
                            } else if (roll < 0.7) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.8) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'crypt';
                                roomData.hasChest = Math.random() < 0.3;
                            }
                        } else if (distanceFromCenter >= 4) {
                            if (roll < 0.45) {
                                roomType = 'enemy';
                                enemyType = Math.random() < 0.6 ? 'orc' : 'skeleton';
                            } else if (roll < 0.65) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.75) {
                                roomType = 'trap';
                            } else if (roll < 0.8) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'empty';
                                roomData.hasChest = Math.random() < 0.2;
                            }
                        } else {
                            if (roll < 0.35) {
                                roomType = 'enemy';
                                enemyType = 'goblin';
                            } else if (roll < 0.55) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.6) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'empty';
                                roomData.hasChest = Math.random() < 0.15;
                            }
                        }
                        if (roomType === 'enemy') {
                            game.dungeon.grid[key] = { type: 'enemy', description: getRandomDescription('enemy'), ...roomData, enemy: { ...enemies[enemyType] } };
                        } else {
                            game.dungeon.grid[key] = { type: roomType, description: getRandomDescription(roomType), ...roomData };
                        }
                    }
                }
            }
            if (Math.random() < 0.3) {
                game.dungeon.hasSecretRoom = true;
            }
            game.player.position = { x: centerX, y: centerY };
            game.currentRoom = game.dungeon.grid[`${centerX},${centerY}`];
        }

        function move(direction) {
            const { x, y } = game.player.position;
            let newX = x, newY = y;
            if (direction === 'north') newY--;
            else if (direction === 'south') newY++;
            else if (direction === 'east') newX++;
            else if (direction === 'west') newX--;

            if (newX < 0 || newX >= game.dungeon.size || newY < 0 || newY >= game.dungeon.size) {
                speak('You cannot go that way. A solid wall blocks your path.');
                return;
            }
            game.player.position = { x: newX, y: newY };
            const key = `${newX},${newY}`;
            game.currentRoom = game.dungeon.grid[key];

            if (game.currentRoom.type === 'trap' && !game.currentRoom.visited) {
                if (game.player.class === 'rogue' && Math.random() < 0.5) {
                    speak('Your rogue instincts avoid a trap!');
                    game.currentRoom.visited = true;
                } else {
                    const trapDamage = 15;
                    game.player.health -= trapDamage;
                    speak(`A trap springs! You take ${trapDamage} damage! Health: ${game.player.health}.`);
                    if (game.player.health <= 0) {
                        setTimeout(() => gameOver(), 1000);
                        return;
                    }
                }
            }
            game.currentRoom.visited = true;
            describeRoom();
        }

        function describeRoom() {
            const room = game.currentRoom;
            const className = classes[game.player.class].name;
            const messages = [`Level ${game.dungeon.currentLevel}: You stand in ${room.description}`];

            if (room.type === 'stairs') {
                messages.push(`${className} senses dark stairs descending deeper. Say "go down stairs" to proceed.`);
            } else if (room.type === 'fountain' && !room.fountainUsed) {
                messages.push(`A magical fountain hums with power. Say "drink fountain" to heal.`);
            } else if (room.enemy && room.enemy.health > 0) {
                messages.push(`A ${room.enemy.name} snarls, ready to strike!`);
                speakSequence(messages, () => {
                    setTimeout(() => startCombat(room.enemy), 1000);
                });
                return;
            } else {
                if (room.hasChest && !room.searched) {
                    messages.push(`Your ${className} instincts spot a treasure chest. Say "open chest" to loot it.`);
                }
                if (!room.searched && room.type !== 'stairs') {
                    messages.push(`Your ${className} senses something hidden. Say "search" to investigate.`);
                }
            }

            messages.push('Which direction will you go? North, south, east, or west.');
            speakSequence(messages);
        }

        function searchRoom() {
            if (game.currentRoom.searched) {
                speak('The room has already been searched. There is nothing left to find.');
                return;
            }
            game.currentRoom.searched = true;
            if (game.currentRoom.type === 'trap') {
                speak('You cautiously search the room, but find nothing.');
                return;
            }

            const roll = Math.random();
            let found = false;
            let messages = [];

            if (game.dungeon.hasSecretRoom && !game.dungeon.secretRoom && roll < 0.1) {
                game.dungeon.secretRoom = { x: game.player.position.x, y: game.player.position.y, found: true };
                messages.push('You discover a hidden crawlspace with a heavy book inside! Say "read book of heal" to learn its ability.');
                game.player.inventory.push('Heal'); // Assuming Heal is the default ability book found in a secret
                found = true;
            }

            if (roll < 0.3) {
                const goldFound = Math.floor(Math.random() * 20) + 5;
                game.player.gold += goldFound;
                messages.push(`You find ${goldFound} gold coins hidden under a loose stone.`);
                found = true;
            }

            if (!found || roll < 0.4) {
                const itemType = Math.random();
                let item = null;
                let itemName = '';

                if (itemType < 0.5) { // Potion
                    itemName = Math.random() < 0.6 ? 'Health Potion' : 'Mana Potion';
                } else if (itemType < 0.8) { // Ring
                    item = rings[Math.floor(Math.random() * rings.length)];
                    itemName = item.name;
                } else { // Equipment
                    const equipList = equipment.weapons.concat(equipment.armor).filter(eq => eq.class === game.player.class);
                    if (equipList.length > 0) {
                        item = equipList[Math.floor(Math.random() * equipList.length)];
                        itemName = item.name;
                    }
                }

                if (itemName) {
                    game.player.inventory.push(itemName);
                    messages.push(`You find a valuable item: a ${itemName}. Say "inventory" to see your items.`);
                    found = true;
                }
            }

            if (messages.length === 0) {
                messages.push('You search thoroughly but find nothing of interest.');
            }

            speakSequence(messages);
        }

        function openChest() {
            if (!game.currentRoom.hasChest || game.currentRoom.searched) {
                speak('There is no chest here, or the chest has already been looted.');
                return;
            }
            game.currentRoom.searched = true;
            let messages = [];

            // Gold reward
            const goldFound = Math.floor(Math.random() * 50) + 20;
            game.player.gold += goldFound;
            messages.push(`The chest creaks open. You find ${goldFound} gold coins!`);

            // Item reward
            const itemRoll = Math.random();
            let itemName = '';
            let isAbilityBook = false;

            if (itemRoll < 0.3) { // Ability Book
                const availableAbilities = abilities.filter(a => a.class === game.player.class && !game.player.learnedAbilities.some(la => la.name === a.name));
                if (availableAbilities.length > 0) {
                    itemName = availableAbilities[Math.floor(Math.random() * availableAbilities.length)].name;
                    isAbilityBook = true;
                } else {
                    itemName = 'Health Potion';
                }
            } else if (itemRoll < 0.5) { // Amulet
                const availableAmulets = amulets.filter(a => !game.player.equippedAmulet || game.player.equippedAmulet !== a.name);
                if (availableAmulets.length > 0) {
                    itemName = availableAmulets[Math.floor(Math.random() * availableAmulets.length)].name;
                } else {
                    itemName = 'Mana Potion';
                }
            } else if (itemRoll < 0.7) { // Ring
                itemName = rings[Math.floor(Math.random() * rings.length)].name;
            } else if (itemRoll < 0.9) { // Treasure
                itemName = treasures[Math.floor(Math.random() * treasures.length)].name;
            } else { // Potion
                itemName = Math.random() < 0.5 ? 'Health Potion' : 'Mana Potion';
            }

            game.player.inventory.push(itemName);
            messages.push(`You also find a valuable item: a ${itemName}.`);

            if (isAbilityBook) {
                messages.push(`Say "read book of ${itemName}" to learn the new skill!`);
            } else if (itemName.includes('Amulet') || itemName.includes('Ring')) {
                messages.push(`Say "equip ${itemName.toLowerCase()}" to use it!`);
            } else {
                messages.push('Check your inventory for more details.');
            }

            speakSequence(messages);
        }

        function processPotionCommand(command) {
            let potionName = '';
            let actionText = '';
            if (command.includes('mana') || command.includes('magic')) {
                potionName = 'Mana Potion';
                actionText = 'restore mana';
            } else if (command.includes('health') || command.includes('heal') || command.includes('life')) {
                potionName = 'Health Potion';
                actionText = 'restore health';
            } else {
                const availablePotions = game.player.inventory.filter(item => item === 'Health Potion' || item === 'Mana Potion');
                if (availablePotions.length > 0) {
                    speak(`You have: ${availablePotions.join(', ')}. Say "use <potion name>".`);
                    return;
                } else {
                    speak('You have no potions to use.');
                    return;
                }
            }

            const potionIndex = game.player.inventory.indexOf(potionName);
            if (potionIndex === -1) {
                speak(`You do not have a ${potionName}.`);
                return;
            }

            let message = '';
            let fullyRestored = false;

            if (potionName === 'Health Potion') {
                if (game.player.health === game.player.maxHealth) {
                    // FIX: Prevent using potion if health is full
                    message = `Your health is already full. You save the Health Potion for later.`;
                    const combatTurn = game.combat ? () => enemyTurn() : null;
                    speak(message, combatTurn);
                    return;
                }
                const healAmount = 50;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + healAmount);
                const actualHeal = game.player.health - oldHealth;
                game.player.inventory.splice(potionIndex, 1);
                message = `You drink the Health Potion and restore ${actualHeal} health!`;
                if (game.player.health === game.player.maxHealth) fullyRestored = true;
            } else if (potionName === 'Mana Potion') {
                if (game.player.mana === game.player.maxMana) {
                    // FIX: Prevent using potion if mana is full
                    message = `Your mana is already full. You save the Mana Potion for later.`;
                    const combatTurn = game.combat ? () => enemyTurn() : null;
                    speak(message, combatTurn);
                    return;
                }
                const manaRestore = 40;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + manaRestore);
                const actualRestore = game.player.mana - oldMana;
                game.player.inventory.splice(potionIndex, 1);
                message = `You drink the Mana Potion and restore ${actualRestore} mana!`;
                if (game.player.mana === game.player.maxMana) fullyRestored = true;
            }

            const combatTurn = game.combat ? () => enemyTurn() : null;
            speak(message, combatTurn);
        }

        function characterStatus() {
            const ringsList = game.player.equippedRings.length > 0 ? game.player.equippedRings.join(', ') : 'None';
            const amulet = game.player.equippedAmulet || 'None';
            const abilitiesList = game.player.learnedAbilities.length > 0 ? game.player.learnedAbilities.map(a => a.name).join(', ') : 'None';
            const expProgress = `${game.player.experience}/${game.player.experienceToNext}`;

            const messages = [
                `You are a level ${game.player.level} ${classes[game.player.class].name}.`,
                `Experience progress: ${expProgress}.`,
                `Health: ${game.player.health} of ${game.player.maxHealth}.`,
                `Mana: ${game.player.mana} of ${game.player.maxMana}.`,
                `Gold: ${game.player.gold}.`,
                `Attack: ${game.player.baseAttack}. Defense: ${game.player.defense}.`,
                `Weapon: ${game.player.weapon || 'None'}. Armor: ${game.player.armor || 'None'}.`,
                `Rings: ${ringsList}.`,
                `Amulet: ${amulet}.`,
                `Learned Abilities: ${abilitiesList}.`
            ];
            speakSequence(messages);
        }

        function listInventory() {
            if (game.player.inventory.length === 0) {
                speak('Your inventory is empty.');
                return;
            }
            const inventoryCounts = game.player.inventory.reduce((counts, item) => {
                counts[item] = (counts[item] || 0) + 1;
                return counts;
            }, {});
            const inventoryList = Object.entries(inventoryCounts).map(([item, count]) => `${item} (x${count})`).join(', ');
            speak(`Your inventory contains: ${inventoryList}. Say "status" for equipped items.`);
        }

        function listCommands() {
            const combatCommands = game.combat ? 'attack, defend, special, use ability, use potion, flee.' : '';
            const explorationCommands = 'north, south, east, west, look, search, open chest, read book, equip <item>, use potion, status, inventory, meditate, save game, load game, help.';
            const messages = [
                'In exploration, your commands are:',
                explorationCommands,
                combatCommands ? 'In combat, your commands are: ' + combatCommands : ''
            ].filter(m => m).join(' ');

            speak(messages);
        }

        function giveHint() {
            if (game.combat) {
                speak(`You are in combat against a ${game.combat.enemy.name}. Say attack, defend, special, or flee.`);
                return;
            } else {
                const room = game.currentRoom;
                if (room.type === 'stairs') {
                    speak('A staircase is here. Say "go down stairs" to descend to the next level.');
                } else if (room.type === 'fountain' && !room.fountainUsed) {
                    speak('There is a magical fountain here. Say "drink fountain" for full healing.');
                } else if (room.hasChest && !room.searched) {
                    speak('There is a chest here. Say open chest.');
                } else if (!room.searched) {
                    speak('You have not searched this room yet. Try searching.');
                } else if (game.player.mana < game.player.maxMana * 0.5) {
                    speak('Your mana is low. Consider saying meditate or use a mana potion.');
                } else if (room.type === 'boss') {
                    speak('This is a boss room. Be prepared for a tough fight.');
                } else {
                    speak('Explore in different directions. The boss is at the far south east corner.');
                }
            }
        }

        function showHelp() {
            speak('Welcome to Echo Dungeon! Tap the button to speak your command. You can say directions like north or east, or actions like search, open chest, status, inventory, or help.');
        }

        function startCombat(enemy) {
            game.combat = { enemy: enemy, playerDefending: false };
            speak(`Combat begins! A ${enemy.name} (Health: ${enemy.health}) attacks! Say attack, defend, special, or flee.`);
        }

        function playerAttack() {
            if (!game.combat) return;
            const enemy = game.combat.enemy;
            let damage = game.player.baseAttack;

            const ringAttack = rings.find(r => r.stat === 'attack' && game.player.equippedRings.includes(r.name));
            if (ringAttack) {
                damage += ringAttack.value;
            }
            
            damage = Math.max(1, damage); // Ensure at least 1 damage
            enemy.health -= damage;

            speak(`You strike the ${enemy.name} for ${damage} damage! Enemy Health: ${Math.max(0, enemy.health)}.`, () => {
                if (enemy.health <= 0) {
                    endCombat('win');
                } else {
                    setTimeout(() => enemyTurn(), 1000);
                }
            });
        }

        function playerDefend() {
            if (!game.combat) return;
            game.combat.playerDefending = true;
            speak('You raise your guard, preparing for the enemy attack.', () => {
                setTimeout(() => enemyTurn(), 1000);
            });
        }

        function playerSpecial() {
            if (!game.combat) return;
            const ability = classes[game.player.class].special;
            if (game.player.mana < ability.cost) {
                speak(`Not enough mana for ${ability.name}. You need ${ability.cost}.`);
                return;
            }
            game.player.mana -= ability.cost;
            game.combat.playerDefending = false;

            let message = '';
            if (ability.type === 'damage') {
                const damage = ability.damage;
                game.combat.enemy.health -= damage;
                message = `You use ${ability.name} for ${damage} powerful damage! Enemy Health: ${Math.max(0, game.combat.enemy.health)}.`;
            }

            speak(message, () => {
                if (game.combat.enemy.health <= 0) {
                    endCombat('win');
                } else {
                    setTimeout(() => enemyTurn(), 1000);
                }
            });
        }

        function enemyTurn() {
            if (!game.combat) return;
            const enemy = game.combat.enemy;

            // Apply poison damage if active
            if (enemy.poisoned) {
                enemy.health -= enemy.poisoned.damage;
                enemy.poisoned.duration--;
                speak(`${enemy.name} takes ${enemy.poisoned.damage} poison damage!`, () => {
                    if (enemy.health <= 0) {
                        endCombat('win');
                        return;
                    }
                    if (enemy.poisoned.duration <= 0) {
                        speak('The poison wears off.');
                        enemy.poisoned = null;
                    }
                    processEnemyAction();
                });
            } else {
                processEnemyAction();
            }

            function processEnemyAction() {
                if (enemy.stunned) {
                    speak(`${enemy.name} is stunned and skips its turn!`);
                    enemy.stunned = false;
                    game.combat.playerDefending = false;
                    return;
                }

                let damage = enemy.damage;
                if (game.combat.playerDefending) {
                    damage = Math.floor(damage / 2);
                }

                damage = Math.max(0, damage - game.player.defense);
                game.player.health -= damage;
                game.combat.playerDefending = false;

                speak(`${enemy.name} attacks you for ${damage} damage! Health: ${Math.max(0, game.player.health)}.`, () => {
                    if (game.player.health <= 0) {
                        gameOver();
                    }
                });
            }
        }

        function attemptFlee() {
            if (!game.combat) return;
            if (Math.random() < game.combat.enemy.fleeChance) {
                endCombat('flee');
                speak('You successfully flee from combat and return to the room.');
            } else {
                speak('You failed to flee!', () => {
                    setTimeout(() => enemyTurn(), 1000);
                });
            }
        }

        function endCombat(outcome) {
            const enemy = game.combat.enemy;
            game.combat = null;

            if (outcome === 'win') {
                const gold = enemy.gold;
                game.player.gold += gold;
                
                // Call gainExperience which now handles the Amulet of Experience bonus
                gainExperience(enemy.exp);

                const messages = [
                    `You defeated the ${enemy.name}!`,
                    `You gained experience and found ${gold} gold!`
                ];

                const room = game.currentRoom;
                if (room.type === 'boss') {
                    messages.push('You have defeated the Dragon! You are free to descend the stairs to the next level.');
                }
                speakSequence(messages, () => {
                    describeRoom();
                });
            } else if (outcome === 'flee') {
                describeRoom();
            }
        }

        function gameOver() {
            game.started = false;
            game.needsClass = true;
            game.combat = null;
            speak('You have been defeated! Your adventure ends here. Refresh the page to start a new game.', () => {
                location.reload();
            });
        }

        function meditate() {
            game.player.mana = game.player.maxMana;
            speak('You meditate and restore your mana fully.', () => {
                const room = game.currentRoom;
                if (room.type === 'enemy' && room.enemy && room.enemy.health > 0) {
                    speak('The enemy stirs...');
                    setTimeout(() => startCombat(room.enemy), 1000);
                } else if (room.type === 'boss' && room.enemy && room.enemy.health > 0) {
                    speak('The Dragon stirs...');
                    setTimeout(() => startCombat(room.enemy), 1000);
                } else {
                    describeRoom();
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            checkBrowserSupport();
            setTimeout(() => {
                speak('Echo Dungeon Enhanced is ready. Tap the screen to begin.');
            }, 1000);
        });

        micButton.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>


