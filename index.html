<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Dungeon Enhanced</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
        }
        #micButton {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #222;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        #micButton:active {
            background: #444;
        }
        .listening {
            background: #004400 !important;
        }
        .start-button {
            background: #000044 !important;
        }
        #textDisplay {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="textDisplay" role="status" aria-live="polite"></div>
    <button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button - Tap to speak"></button>

    <script>
        const micButton = document.getElementById('micButton');
        const textDisplay = document.getElementById('textDisplay');

        function displayText(text) {
            textDisplay.innerHTML = text;
        }

        let browserSupport = {
            speechSynthesis: false,
            speechRecognition: false,
            https: false
        };

        function checkBrowserSupport() {
            browserSupport.https = window.location.protocol === 'https:' || window.location.hostname === 'localhost';
            browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
            browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
        }

        const game = {
            player: {
                class: '',
                level: 1,
                experience: 0,
                experienceToNext: 100,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                gold: 25,
                inventory: [],
                equippedRings: [], // Max 5 rings
                learnedAbilities: [],
                equippedAmulet: '',
                position: { x: 5, y: 5 },
                baseAttack: 15,
                defense: 0,
                weapon: '',
                armor: '',
                shield: '',
                markedFleeRoom: null
            },
            dungeon: {
                grid: {},
                size: 10,
                secretRoom: null,
                hasSecretRoom: false,
                currentLevel: 1 
            },
            currentRoom: null,
            combat: null,
            listening: false,
            started: false,
            needsClass: true,
            initialized: false,
            phase: 'init'
        };

        const classes = {
            warrior: {
                name: 'Warrior',
                health: 120,
                maxHealth: 120,
                mana: 30,
                maxMana: 30,
                gold: 50,
                items: ['Steel Sword', 'Health Potion', 'Health Potion', 'Chainmail', 'Iron Shield'],
                special: { name: 'Power Strike', damage: 40, cost: 15, type: 'damage' }
            },
            mage: { 
                name: 'Mage',
                health: 80,
                maxHealth: 80,
                mana: 100,
                maxMana: 100,
                gold: 75,
                items: ['Mystic Staff', 'Mana Potion', 'Health Potion', 'Enchanted Robes'],
                special: { name: 'Fireball', damage: 30, cost: 20, type: 'damage' } 
            },
            rogue: {
                name: 'Rogue',
                health: 100,
                maxHealth: 100,
                mana: 60,
                maxMana: 60,
                gold: 100,
                items: ['Shadow Daggers', 'Lockpicks', 'Health Potion', 'Shadow Leather'],
                special: { name: 'Backstab', damage: 35, cost: 25, type: 'damage' }
            }
        };

        const equipment = {
            weapons: [
                { name: 'Steel Sword', attack: 8, class: 'warrior', value: 100 },
                { name: 'Mystic Staff', attack: 10, class: 'mage', value: 150 },
                { name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120 },
                { name: 'Legendary Greatsword', attack: 15, class: 'warrior', value: 300 },
                { name: 'Archmage Staff', attack: 18, class: 'mage', value: 350 },
                { name: 'Vorpal Daggers', attack: 16, class: 'rogue', value: 320 },
                // New Level 3+ Equipment
                { name: 'Runic Blade', attack: 22, class: 'warrior', value: 500 },
                { name: 'Scepter of Power', attack: 25, class: 'mage', value: 600 },
                { name: 'Silencer Blades', attack: 24, class: 'rogue', value: 550 }
            ],
            armor: [
                { name: 'Chainmail', defense: 8, class: 'warrior', value: 100 },
                { name: 'Enchanted Robes', defense: 5, class: 'mage', value: 120 },
                { name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110 },
                { name: 'Dragonscale Plate', defense: 15, class: 'warrior', value: 350 },
                { name: 'Arcane Vestments', defense: 12, class: 'mage', value: 380 },
                { name: 'Phantom Suit', defense: 13, class: 'rogue', value: 360 },
                // New Level 3+ Equipment
                { name: 'Aegis Plate', defense: 20, class: 'warrior', value: 550 },
                { name: 'Celestial Robes', defense: 16, class: 'mage', value: 650 },
                { name: 'Shade Armor', defense: 18, class: 'rogue', value: 600 }
            ],
            shields: [
                { name: 'Iron Shield', defense: 5, class: 'warrior', value: 80 },
                { name: 'Tower Shield', defense: 10, class: 'warrior', value: 250 },
                // New Level 3+ Equipment
                { name: 'Adamantine Shield', defense: 15, class: 'warrior', value: 400 }
            ]
        };

        const abilities = [
            { name: 'Icy Blast', damage: 25, cost: 25, type: 'freeze', description: 'Deals damage and freezes enemy for 1 turn', class: 'mage' },
            { name: 'Shield Bash', damage: 30, cost: 20, type: 'stun', description: 'Stun enemy for one turn', class: 'warrior' },
            { name: 'Poison Blade', damage: 20, cost: 20, type: 'poison', duration: 3, description: 'Poison damages 5 per turn for 3 turns', class: 'rogue' }
        ];

        // Amulet template with a function to create an instance with level scaling
        const amulets = [
            { name: 'Amulet of Vitality', stat: 'maxHealth', baseValue: 15, scale: (lvl) => Math.floor(15 + (lvl - 1) * 5), effect: 'Max Health' },
            { name: 'Amulet of Mana', stat: 'maxMana', baseValue: 15, scale: (lvl) => Math.floor(15 + (lvl - 1) * 5), effect: 'Max Mana' },
            { name: 'Amulet of Experience', stat: 'expGain', baseValue: 1.2, scale: (lvl) => 1.2 + (lvl - 1) * 0.05, effect: 'Experience Gain' }
        ];

        const roomTypes = {
            entrance: { 
                descriptions: [
                    'the grand entrance hall. Torches flicker on ancient stone walls.',
                    'the entrance chamber. A faded tapestry hangs on the north wall.',
                    'the starting hall. Cobwebs drape from vaulted ceilings above.'
                ], 
                hasEnemy: false 
            },
            empty: { 
                descriptions: [
                    'an abandoned barracks. Rusty weapons litter the floor.',
                    'a collapsed library. Torn pages scatter at your feet.',
                    'a crumbling shrine. A broken altar stands in the center.',
                    'a forgotten armory. Empty weapon racks line the walls.',
                    'a dusty workshop. Ancient tools hang from hooks.',
                    'a meditation chamber. Stone benches circle a dry fountain.',
                    'an old prison cell. Iron bars have rusted through.',
                    'a guard post. A skeleton sits slumped in a chair.'
                ], 
                hasEnemy: false 
            },
            treasure: { 
                descriptions: [
                    'a glittering treasure vault. Gold coins reflect torchlight.',
                    'a dragon\'s hoard chamber. Piles of jewels gleam in the darkness.',
                    'a royal treasury. Ancient chests overflow with riches.',
                    'a pirate\'s cache. Stolen goods fill every corner.',
                    'a wizard\'s vault. Magical artifacts pulse with energy.'
                ], 
                hasEnemy: false 
            },
            enemy: { 
                descriptions: [
                    'a dark chamber. You sense hostile eyes watching you.',
                    'a blood-stained arena. Old battle scars mark the floor.',
                    'a shadowy lair. Something growls in the darkness.',
                    'a monster\'s den. Bones crunch beneath your feet.',
                    'a cursed chamber. An evil presence fills the air.'
                ], 
                hasEnemy: true 
            },
            boss: { 
                descriptions: [
                    'the throne room of darkness. A massive beast awaits on a stone throne.',
                    'the dragon\'s lair. Heat radiates from the enormous creature before you.',
                    'the demon king\'s chamber. Dark energy swirls around your foe.'
                ], 
                hasEnemy: true 
            },
            trap: { 
                descriptions: [
                    'a trapped corridor. Pressure plates cover the floor.',
                    'a spike-filled chamber. Deadly traps line the walls.',
                    'a poison gas room. Strange vapors seep from cracks.'
                ], 
                hasEnemy: false 
            },
            stairs: { 
                descriptions: [
                    'a spiral stairwell. Dark stone steps descend into deeper darkness.',
                    'a grand staircase. Ancient carvings decorate the descent.',
                    'a hidden passage. Secret stairs lead to the next level.'
                ], 
                hasEnemy: false 
            },
            fountain: {
                descriptions: [
                    'a magical fountain room. Crystal clear water bubbles from an enchanted spring.',
                    'an ancient healing shrine. A mystical fountain glows with restorative power.'
                ],
                hasEnemy: false
            },
            crypt: {
                descriptions: [
                    'a dusty crypt. Stone sarcophagi line the walls.',
                    'an ancient burial chamber. Skeletal remains rest in alcoves.',
                    'a forgotten tomb. Hieroglyphs cover every surface.'
                ],
                hasEnemy: false
            }
        };

        const enemies = {
            goblin: { name: 'Goblin', health: 30, damage: 8, gold: 5, exp: 15, fleeChance: 0.8 },
            skeleton: { name: 'Skeleton', health: 40, damage: 10, gold: 8, exp: 20, fleeChance: 0.7 },
            orc: { name: 'Orc', health: 60, damage: 15, gold: 12, exp: 30, fleeChance: 0.5 },
            wraith: { name: 'Wraith', health: 50, damage: 18, gold: 15, exp: 35, fleeChance: 0.6 },
            troll: { name: 'Troll', health: 80, damage: 20, gold: 20, exp: 45, fleeChance: 0.4 },
            dragon: { name: 'Dragon', health: 150, damage: 30, gold: 50, exp: 100, fleeChance: 0.1 },
            demon: { name: 'Demon', health: 120, damage: 28, gold: 45, exp: 80, fleeChance: 0.3 },
            vampire: { name: 'Vampire', health: 100, damage: 25, gold: 40, exp: 70, fleeChance: 0.4 },
            // Elite versions (bigger monsters)
            orcChieftain: { name: 'Orc Chieftain', health: 90, damage: 22, gold: 18, exp: 45, fleeChance: 0.4 },
            ancientWraith: { name: 'Ancient Wraith', health: 75, damage: 25, gold: 22, exp: 50, fleeChance: 0.5 },
            elderTroll: { name: 'Elder Troll', health: 120, damage: 28, gold: 30, exp: 65, fleeChance: 0.3 },
            archDemon: { name: 'Arch Demon', health: 160, damage: 35, gold: 60, exp: 110, fleeChance: 0.2 },
            vampireLord: { name: 'Vampire Lord', health: 140, damage: 32, gold: 55, exp: 95, fleeChance: 0.3 }
        };

        const treasures = [
            { name: 'Sapphire Gem', value: 50 },
            { name: 'Ruby Gem', value: 75 },
            { name: 'Diamond', value: 100 },
            { name: 'Emerald', value: 60 },
            { name: 'Ancient Coin Collection', value: 40 },
            { name: 'Golden Chalice', value: 80 },
            { name: 'Silver Crown', value: 90 },
            { name: 'Enchanted Amulet', value: 120 }
        ];

        // Ring template with a function to create an instance with level scaling
        const rings = [
            { name: 'Ring of Vitality', stat: 'maxHealth', baseValue: 10, scale: (lvl) => Math.floor(10 + (lvl - 1) * 3), effect: 'Max Health' },
            { name: 'Ring of Minor Mana', stat: 'maxMana', baseValue: 10, scale: (lvl) => Math.floor(10 + (lvl - 1) * 3), effect: 'Max Mana' },
            { name: 'Ring of Protection', stat: 'maxHealth', baseValue: 5, scale: (lvl) => Math.floor(5 + (lvl - 1) * 2), effect: 'Max Health' },
            { name: 'Ring of Strength', stat: 'attack', baseValue: 2, scale: (lvl) => Math.floor(2 + (lvl - 1) * 1), effect: 'Attack Damage' },
            { name: 'Ring of Wisdom', stat: 'maxMana', baseValue: 5, scale: (lvl) => Math.floor(5 + (lvl - 1) * 2), effect: 'Max Mana' }
        ];

        // Helper to find the actual ring/amulet data and its scaled value
        function getAccessoryData(itemName, isEquipping = false) {
            const level = isEquipping ? game.dungeon.currentLevel : 1; // Only scale on first equip/discovery
            
            // Check if item is already fully defined (e.g., from save game or a previous equip)
            if (typeof itemName === 'object' && itemName !== null && itemName.scaledName) {
                return itemName;
            }

            const itemType = itemName.includes('Ring') ? rings : itemName.includes('Amulet') ? amulets : null;
            if (!itemType) return null;

            const baseItem = itemType.find(i => i.name === itemName);
            if (!baseItem) return null;

            const scaledValue = baseItem.scale(level);
            
            // Create a unique, scaled instance of the item
            const scaledName = `${baseItem.name} (Lvl ${level}, ${baseItem.effect}: +${baseItem.stat === 'expGain' ? ((scaledValue - 1) * 100).toFixed(0) + '%' : scaledValue})`;

            return {
                ...baseItem,
                name: scaledName, // The unique instance name for inventory
                scaledName: scaledName,
                value: scaledValue,
                baseName: baseItem.name // The original name for lookup
            };
        }

        function speak(text, callback) {
            displayText(text);
            if (!browserSupport.speechSynthesis) {
                if (callback) setTimeout(callback, 2000);
                return;
            }
            try {
                speechSynthesis.cancel();
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g, ''));
                    utterance.rate = 0.9;
                    if (callback) {
                        utterance.onend = callback;
                        utterance.onerror = callback;
                    }
                    speechSynthesis.speak(utterance);
                }, 100);
            } catch (error) {
                if (callback) setTimeout(callback, 2000);
            }
        }

        function speakSequence(messages, callback) {
            if (messages.length === 0) {
                if (callback) callback();
                return;
            }
            const [first, ...rest] = messages;
            speak(first, () => {
                if (rest.length > 0) {
                    setTimeout(() => speakSequence(rest, callback), 500);
                } else if (callback) {
                    callback();
                }
            });
        }

        let recognition = null;

        function startListening() {
            if (!browserSupport.speechRecognition || !browserSupport.https) {
                speak('Voice recognition requires HTTPS and a compatible browser like Chrome or Edge.');
                return;
            }
            if (game.listening) { stopListening(); return; }
            try {
                const Recognition = window.webkitSpeechRecognition || window.SpeechRecognition;
                recognition = new Recognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.onstart = () => {
                    game.listening = true;
                    micButton.classList.add('listening');
                };
                recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase().trim();
                    displayText(`You said: "${command}"`);
                    stopListening();
                    setTimeout(() => processCommand(command), 500);
                };
                recognition.onerror = (event) => {
                    stopListening();
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        speak('Voice error. Try again.');
                    }
                };
                recognition.onend = () => stopListening();
                recognition.start();
            } catch (error) {
                speak('Failed to start voice recognition.');
                stopListening();
            }
        }

        function stopListening() {
            game.listening = false;
            micButton.classList.remove('listening');
            if (recognition) {
                try { recognition.stop(); } catch (e) {}
                recognition = null;
            }
        }

        function saveGame() {
            const saveData = {
                player: game.player,
                dungeon: {
                    grid: game.dungeon.grid,
                    currentLevel: game.dungeon.currentLevel,
                    size: game.dungeon.size,
                    hasSecretRoom: game.dungeon.hasSecretRoom
                }
            };
            const saveStr = JSON.stringify(saveData);
            const pin = Math.floor(1000 + Math.random() * 9000).toString();
            localStorage.setItem(`echoDungeon_${pin}`, saveStr);
            const spokenPin = pin.split('').join(' ');
            speak(`Game saved! Your save PIN is ${spokenPin}. Say "load game" then "code ${spokenPin}" to load.`);
        }

        function loadGame(pin) {
            try {
                const saveStr = localStorage.getItem(`echoDungeon_${pin}`);
                if (!saveStr) {
                    speak(`No game found for PIN ${pin.split('').join(' ')}. Try another PIN or start a new game.`);
                    return;
                }
                const saveData = JSON.parse(saveStr);
                
                // Re-apply scaled stats on load
                if (saveData.player.equippedAmulet) {
                     saveData.player.equippedAmulet = getAccessoryData(saveData.player.equippedAmulet);
                }
                saveData.player.equippedRings = saveData.player.equippedRings.map(r => getAccessoryData(r));

                game.player = saveData.player;
                game.dungeon.grid = saveData.dungeon.grid;
                game.dungeon.currentLevel = saveData.dungeon.currentLevel;
                game.dungeon.size = saveData.dungeon.size;
                game.dungeon.hasSecretRoom = saveData.dungeon.hasSecretRoom;
                const key = `${game.player.position.x},${game.player.position.y}`;
                game.currentRoom = game.dungeon.grid[key];
                game.initialized = true;
                game.started = true;
                game.needsClass = false;
                game.phase = 'exploration';
                micButton.classList.remove('start-button');
                speak(`Game loaded! You are a level ${game.player.level} ${classes[game.player.class].name} on Dungeon Level ${game.dungeon.currentLevel}.`, () => {
                    describeRoom();
                });
            } catch (e) {
                speak('Error loading game. The PIN may be incorrect.');
            }
        }

        function initializeGame() {
            game.initialized = true;
            micButton.classList.remove('start-button');
            speak("Welcome to Echo Dungeon Enhanced! Say 'load game' and provide your save PIN, or choose your class: warrior, mage, or rogue."); 
        }

        function handleClick() {
            if (!game.initialized) {
                initializeGame();
            } else {
                startListening();
            }
        }

        function processCommand(command) {
            if (command.includes('save game') || command.includes('save')) { 
                saveGame(); 
                return; 
            }
            
            if (command.includes('load game') || command.includes('load')) {
                speak('Please say your save PIN after the word "code".');
                game.phase = 'loading';
                return;
            }
            
            if (command.includes('code ') && game.phase === 'loading') {
                const pin = command.split('code ')[1].trim().replace(/\s/g, '');
                loadGame(pin);
                return;
            }

            if (game.needsClass) {
                if (command.includes('warrior') || command.includes('fighter')) selectClass('warrior');
                else if (command.includes('mage') || command.includes('wizard')) selectClass('mage'); 
                else if (command.includes('rogue') || command.includes('thief')) selectClass('rogue');
                else speak('Please say warrior, mage, or rogue.');
                return;
            }

            if (game.combat) {
                if (command.includes('attack') || command.includes('fight')) playerAttack();
                else if (command.includes('defend') || command.includes('block') || command.includes('guard')) playerDefend();
                else if (command.includes('special') || command.includes('ability')) playerSpecial();
                else if (command.includes('cast') || command.includes('spell')) castSpell(command);
                else if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) processPotionCommand(command); 
                else if (command.includes('flee') || command.includes('run') || command.includes('escape')) attemptFlee();
                else speak('Say attack, defend, special, cast spell, use potion, or flee.');
                return;
            }

            if (command.includes('mark') || command.includes('mark room')) markFleeRoom();
            else if (command.includes('status') || command.includes('stats') || command.includes('check')) characterStatus();
            else if (command.includes('inventory') || command.includes('items') || command.includes('bag')) listInventory();
            else if (command.includes('commands') || command.includes('what can i')) listCommands();
            else if (command.includes('hint') || command.includes('help me')) giveHint();
            else if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) processPotionCommand(command); 
            else if (command.includes('north') || command.includes('forward')) move('north');
            else if (command.includes('south') || command.includes('back')) move('south');
            else if (command.includes('east') || command.includes('right')) move('east');
            else if (command.includes('west') || command.includes('left')) move('west');
            else if (command.includes('meditate') || command.includes('rest')) meditate(); 
            else if (command.includes('look') || command.includes('around') || command.includes('where')) describeRoom();
            else if (command.includes('search') || command.includes('examine')) searchRoom();
            else if (command.includes('open chest') || command.includes('chest') || command.includes('loot')) openChest();
            else if (command.includes('fountain') || command.includes('drink water')) useFountain();
            else if (command.includes('stairs') || command.includes('go down') || command.includes('descend')) useStairs();
            else if (command.includes('wear ring') || command.includes('equip ring') || command.includes('put on ring')) equipRing(command);
            else if (command.includes('equip amulet') || command.includes('wear amulet') || command.includes('put on amulet')) equipAmulet(command);
            else if (command.includes('equip') || command.includes('wear')) equipItem(command);
            else if (command.includes('read book') || command.includes('read') || command.includes('learn')) readBook(command);
            else if (command.includes('use lockpicks') || command.includes('lockpick')) useLockpicks();
            else if (command.includes('help')) showHelp();
            else speak('Unknown command. Say help for options.');
        }

        function markFleeRoom() {
            if (game.combat) {
                speak('You cannot mark a room during combat!');
                return;
            }
            
            if (game.currentRoom.type === 'enemy' || game.currentRoom.type === 'boss') {
                speak('You cannot mark a dangerous room as your flee point.');
                return;
            }
            
            game.player.markedFleeRoom = {
                x: game.player.position.x,
                y: game.player.position.y
            };
            
            speak(`This room is now marked as your flee destination. If you flee from combat, you will return here.`);
        }

        function gainExperience(exp) {
            let actualExp = exp;
            
            // Check for equipped amulet
            const equippedAmuletData = game.player.equippedAmulet ? getAccessoryData(game.player.equippedAmulet) : null;
            if (equippedAmuletData && equippedAmuletData.stat === 'expGain') {
                actualExp = Math.floor(exp * equippedAmuletData.value);
            }
            game.player.experience += actualExp;
            
            if (game.player.experience >= game.player.experienceToNext) {
                levelUp();
            }
        }

        function levelUp() {
            game.player.level++;
            game.player.experience -= game.player.experienceToNext;
            game.player.experienceToNext = Math.floor(game.player.experienceToNext * 1.5);
            
            const healthGain = 20;
            const manaGain = 10;
            
            game.player.maxHealth += healthGain;
            game.player.health = game.player.maxHealth;
            game.player.maxMana += manaGain;
            game.player.mana = game.player.maxMana;
            
            speakSequence([
                `Level up! You are now level ${game.player.level}!`,
                `Max health increased by ${healthGain}!`,
                `Max mana increased by ${manaGain}!`,
                `Fully healed and restored!`
            ]);
        }
        
        // --- START FIX for Rings/Amulets/Mage ---
        // Function to remove equipped item effects from player stats
        function unequipAccessory(accessoryObject) {
            const data = getAccessoryData(accessoryObject);
            if (data.stat === 'maxHealth') {
                game.player.maxHealth -= data.value;
                game.player.health = Math.min(game.player.health, game.player.maxHealth); // Don't heal on unequip, but don't exceed new max
            } else if (data.stat === 'maxMana') {
                game.player.maxMana -= data.value;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
            } else if (data.stat === 'attack') {
                // Ring of Strength is checked in playerAttack, no need to adjust baseAttack here
            }
        }

        function equipRing(command) {
            // Find a ring name from the base list or by unique scaled name in inventory
            const targetBaseName = command.includes('vitality') || command.includes('health') ? 'Ring of Vitality' :
                             command.includes('mana') || command.includes('minor mana') || command.includes('mana ring') ? 'Ring of Minor Mana' :
                             command.includes('protection') ? 'Ring of Protection' :
                             command.includes('strength') ? 'Ring of Strength' :
                             command.includes('wisdom') ? 'Ring of Wisdom' : null;
                             
            // Find the index of the specific ring instance in the inventory
            const ringIndex = game.player.inventory.findIndex(item => 
                (typeof item === 'object' && item.baseName === targetBaseName) || 
                (typeof item === 'string' && item.includes(targetBaseName)) 
            );
            
            if (ringIndex === -1) {
                const availableRings = game.player.inventory.filter(item => 
                    rings.some(r => r.name === (typeof item === 'object' ? item.baseName : item))
                ).map(r => typeof r === 'object' ? r.scaledName : r);
                
                if (availableRings.length > 0) {
                    speak(`You have: ${availableRings.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no rings to equip. Find them in treasure chests or by searching rooms.');
                }
                return;
            }

            const ringToEquip = game.player.inventory[ringIndex];
            
            // Get the fully scaled data (This also handles the case where it was an unscaled string in inventory)
            const ringData = getAccessoryData(ringToEquip, true);

            if (game.player.equippedRings.length >= 5) {
                speak(`Your fingers are full! You can only equip 5 rings. Say "unequip ring" followed by the ring's name to swap it.`);
                return;
            }

            // Remove from inventory
            game.player.inventory.splice(ringIndex, 1);
            
            // Equip the scaled ring object (not just the string)
            game.player.equippedRings.push(ringData);

            if (ringData.stat === 'maxHealth') {
                game.player.maxHealth += ringData.value;
                game.player.health += ringData.value;
            } else if (ringData.stat === 'maxMana') {
                game.player.maxMana += ringData.value;
                game.player.mana += ringData.value;
            }
            
            speak(`You equip the ${ringData.name}. Your ${ringData.effect} increased by ${ringData.value}!`);
        }
        
        function unequipRing(command) {
            const equippedRing = game.player.equippedRings.find(r => command.includes(r.baseName.toLowerCase().replace('ring of ', '').trim()));

            if (!equippedRing) {
                speak(`You are not wearing that ring. Equipped rings are: ${game.player.equippedRings.map(r => r.scaledName).join(', ')}.`);
                return;
            }

            const equippedIndex = game.player.equippedRings.indexOf(equippedRing);

            // Remove effects
            unequipAccessory(equippedRing);

            // Move to inventory
            game.player.equippedRings.splice(equippedIndex, 1);
            game.player.inventory.push(equippedRing);
            
            speak(`You unequip the ${equippedRing.scaledName}. It is now in your inventory.`);
        }


        function equipAmulet(command) {
            const targetBaseName = command.includes('vitality') ? 'Amulet of Vitality' :
                               command.includes('mana') ? 'Amulet of Mana' :
                               command.includes('experience') ? 'Amulet of Experience' : null;

            // Find the index of the specific amulet instance in the inventory
            const amuletIndex = game.player.inventory.findIndex(item => 
                (typeof item === 'object' && item.baseName === targetBaseName) || 
                (typeof item === 'string' && item.includes(targetBaseName))
            );
            
            if (amuletIndex === -1) {
                const availableAmulets = game.player.inventory.filter(item => 
                    amulets.some(a => a.name === (typeof item === 'object' ? item.baseName : item))
                ).map(a => typeof a === 'object' ? a.scaledName : a);
                
                if (availableAmulets.length > 0) {
                    speak(`You have: ${availableAmulets.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no amulets to equip. Find them in treasure chests or by searching rooms.');
                }
                return;
            }

            const amuletToEquip = game.player.inventory[amuletIndex];
            // Get the fully scaled data
            const amuletData = getAccessoryData(amuletToEquip, true);

            if (game.player.equippedAmulet) {
                // Unequip old amulet first
                const oldAmulet = game.player.equippedAmulet;
                unequipAccessory(oldAmulet);
                
                // Put old amulet back into inventory
                game.player.inventory.push(oldAmulet);
            }

            // Remove new amulet from inventory and equip it
            game.player.inventory.splice(amuletIndex, 1);
            game.player.equippedAmulet = amuletData;

            let message = `You equip the ${amuletData.name}.`;

            if (amuletData.stat === 'maxHealth') {
                game.player.maxHealth += amuletData.value;
                game.player.health += amuletData.value;
                message += ` Your max health increased by ${amuletData.value}!`;
            } else if (amuletData.stat === 'maxMana') {
                game.player.maxMana += amuletData.value;
                game.player.mana += amuletData.value;
                message += ` Your max mana increased by ${amuletData.value}!`;
            } else if (amuletData.stat === 'expGain') {
                message += ` You now gain ${((amuletData.value - 1) * 100).toFixed(0)}% more experience!`;
            }
            
            speak(message);
        }
        // --- END FIX for Rings/Amulets/Mage ---
        
        // --- ORIGINAL CODE BREAK ---

                function unequipRing(command) {
            // Find the ring based on a keyword in the command (e.g., 'vitality')
            const equippedRing = game.player.equippedRings.find(r => 
                r.baseName.toLowerCase().includes(command.toLowerCase().replace('unequip ring', '').trim())
            );

            if (!equippedRing) {
                speak(`You are not wearing that ring. Equipped rings are: ${game.player.equippedRings.map(r => r.scaledName).join(', ')}.`);
                return;
            }

            const equippedIndex = game.player.equippedRings.indexOf(equippedRing);

            // Remove effects
            unequipAccessory(equippedRing);

            // Move to inventory (The scaled object is put back in inventory)
            game.player.equippedRings.splice(equippedIndex, 1);
            game.player.inventory.push(equippedRing);
            
            speak(`You unequip the ${equippedRing.scaledName}. It is now in your inventory.`);
        }

        function unequipAmulet() {
            if (!game.player.equippedAmulet) {
                speak('You do not have an amulet equipped.');
                return;
            }
            
            const oldAmulet = game.player.equippedAmulet;
            
            // Remove effects
            unequipAccessory(oldAmulet);

            // Move to inventory
            game.player.equippedAmulet = null;
            game.player.inventory.push(oldAmulet);
            
            speak(`You unequip the ${oldAmulet.scaledName}. It is now in your inventory.`);
        }
        
        // Helper to get total player damage
        function getPlayerDamage() {
            let baseDamage = game.player.baseAttack;
            
            // Check for weapon
            const weapon = equipment.weapons.find(w => w.name === game.player.weapon);
            if (weapon) {
                baseDamage += weapon.attack;
            }

            // Check for Ring of Strength
            const strengthRings = game.player.equippedRings.filter(r => r.stat === 'attack');
            strengthRings.forEach(ring => {
                const data = getAccessoryData(ring);
                baseDamage += data.value;
            });
            
            return baseDamage;
        }
        
        // Helper to get total player defense
        function getPlayerDefense() {
            let totalDefense = game.player.defense;
            
            // Check for armor
            const armor = equipment.armor.find(a => a.name === game.player.armor);
            if (armor) {
                totalDefense += armor.defense;
            }
            
            // Check for shield
            const shield = equipment.shields.find(s => s.name === game.player.shield);
            if (shield) {
                totalDefense += shield.defense;
            }
            
            return totalDefense;
        }

        function rollDice(sides) {
            return Math.floor(Math.random() * sides) + 1;
        }

        function randomItem(list) {
            return list[Math.floor(Math.random() * list.length)];
        }

        function selectClass(className) {
            if (!classes[className]) {
                speak('Invalid class. Choose warrior, mage, or rogue.');
                return;
            }

            const classData = classes[className];
            game.player.class = className;
            game.player.maxHealth = classData.maxHealth;
            game.player.health = classData.health;
            game.player.maxMana = classData.maxMana;
            game.player.mana = classData.mana;
            game.player.gold = classData.gold;
            game.player.inventory = [...classData.items];

            // Equip starting gear (handled separately for visual/stat updates)
            if (className === 'warrior') {
                game.player.weapon = 'Steel Sword';
                game.player.armor = 'Chainmail';
                game.player.shield = 'Iron Shield';
            } else if (className === 'mage') {
                game.player.weapon = 'Mystic Staff';
                game.player.armor = 'Enchanted Robes';
            } else if (className === 'rogue') {
                game.player.weapon = 'Shadow Daggers';
                game.player.armor = 'Shadow Leather';
            }
            
            game.needsClass = false;
            game.started = true;
            game.phase = 'exploration';
            
            // Immediately generate the dungeon after class selection
            generateDungeon();

            speak(`You have chosen the ${classData.name} class! Your starting gear has been equipped. You enter the dungeon on Level ${game.dungeon.currentLevel}.`, () => {
                describeRoom();
            });
        }
        
        function generateDungeon() {
            game.dungeon.grid = {};
            // Make the dungeon a little larger for higher levels, max 15
            game.dungeon.size = Math.min(10 + (game.dungeon.currentLevel - 1) * 2, 15);
            game.dungeon.hasSecretRoom = rollDice(10) <= 3; // 30% chance of a secret room per level
            game.dungeon.secretRoom = null;
            
            const gridSize = game.dungeon.size;
            
            // Always set starting position to center or near center
            game.player.position = { 
                x: Math.floor(gridSize / 2), 
                y: Math.floor(gridSize / 2) 
            };
            
            // Generate rooms
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const key = `${x},${y}`;
                    const room = {
                        x: x,
                        y: y,
                        type: 'empty',
                        visited: false,
                        description: randomItem(roomTypes.empty.descriptions),
                        loot: null,
                        enemy: null,
                        trap: false
                    };

                    const distanceToCenter = Math.abs(x - game.player.position.x) + Math.abs(y - game.player.position.y);
                    const isStart = x === game.player.position.x && y === game.player.position.y;
                    
                    if (isStart) {
                        room.type = 'entrance';
                        room.description = randomItem(roomTypes.entrance.descriptions);
                    } else if (distanceToCenter > 1) { // Avoid generating tough rooms right next to start
                        const dice = rollDice(100);

                        if (dice < 10 && game.dungeon.currentLevel > 1) {
                            room.type = 'stairs';
                            room.description = randomItem(roomTypes.stairs.descriptions);
                        } else if (dice < 25) {
                            room.type = 'treasure';
                            room.description = randomItem(roomTypes.treasure.descriptions);
                            room.loot = randomItem(treasures);
                        } else if (dice < 55) {
                            room.type = 'enemy';
                            room.description = randomItem(roomTypes.enemy.descriptions);
                            room.enemy = generateEnemy();
                        } else if (dice < 65) {
                            room.type = 'trap';
                            room.description = randomItem(roomTypes.trap.descriptions);
                            room.trapDamage = rollDice(20) + (game.dungeon.currentLevel * 5);
                        } else if (dice < 70) {
                            room.type = 'fountain';
                            room.description = randomItem(roomTypes.fountain.descriptions);
                        } else if (dice < 80) {
                            room.type = 'crypt';
                            room.description = randomItem(roomTypes.crypt.descriptions);
                        }
                    }
                    game.dungeon.grid[key] = room;
                }
            }
            
            // Ensure stairs exist if not generated randomly
            if (!Object.values(game.dungeon.grid).some(r => r.type === 'stairs')) {
                let stairX, stairY;
                do {
                    stairX = rollDice(gridSize) - 1;
                    stairY = rollDice(gridSize) - 1;
                } while (stairX === game.player.position.x && stairY === game.player.position.y);
                
                const stairKey = `${stairX},${stairY}`;
                game.dungeon.grid[stairKey].type = 'stairs';
                game.dungeon.grid[stairKey].description = randomItem(roomTypes.stairs.descriptions);
                game.dungeon.grid[stairKey].hasEnemy = false;
                game.dungeon.grid[stairKey].loot = null;
                game.dungeon.grid[stairKey].trap = false;
            }
            
            // Place boss room far away (Level 3+)
            if (game.dungeon.currentLevel >= 3) {
                 let bossX, bossY;
                do {
                    bossX = rollDice(gridSize) - 1;
                    bossY = rollDice(gridSize) - 1;
                    // Ensure boss is far from start and not on stairs
                    const distance = Math.abs(bossX - game.player.position.x) + Math.abs(bossY - game.player.position.y);
                } while (distance < gridSize / 2 || game.dungeon.grid[`${bossX},${bossY}`].type === 'stairs');

                const bossKey = `${bossX},${bossY}`;
                game.dungeon.grid[bossKey].type = 'boss';
                game.dungeon.grid[bossKey].description = randomItem(roomTypes.boss.descriptions);
                game.dungeon.grid[bossKey].enemy = generateBoss();
                game.dungeon.grid[bossKey].hasEnemy = true;
                game.dungeon.grid[bossKey].loot = null;
            }
            
            // Get the current room object
            const key = `${game.player.position.x},${game.player.position.y}`;
            game.currentRoom = game.dungeon.grid[key];
            game.currentRoom.visited = true;
        }

        function generateEnemy() {
            // Scale enemy difficulty by dungeon level
            const enemyList = Object.values(enemies);
            const levelFactor = game.dungeon.currentLevel * 0.1;
            
            let baseEnemy = randomItem(enemyList.filter(e => e.name !== 'Dragon')); 

            // Scale enemy stats
            const scaledHealth = Math.floor(baseEnemy.health * (1 + levelFactor));
            const scaledDamage = Math.floor(baseEnemy.damage * (1 + levelFactor));
            const scaledGold = Math.floor(baseEnemy.gold * (1 + levelFactor * 0.5));
            const scaledExp = Math.floor(baseEnemy.exp * (1 + levelFactor));
            
            return {
                ...baseEnemy,
                health: scaledHealth,
                maxHealth: scaledHealth,
                damage: scaledDamage,
                gold: scaledGold,
                exp: scaledExp
            };
        }
        
        function generateBoss() {
            const bossTemplate = enemies.dragon;
            const levelFactor = game.dungeon.currentLevel * 0.2; // Bosses scale harder
            
            const scaledHealth = Math.floor(bossTemplate.health * (1 + levelFactor));
            const scaledDamage = Math.floor(bossTemplate.damage * (1 + levelFactor));
            const scaledGold = Math.floor(bossTemplate.gold * (1 + levelFactor));
            const scaledExp = Math.floor(bossTemplate.exp * (1 + levelFactor));
            
            return {
                ...bossTemplate,
                name: `The Level ${game.dungeon.currentLevel} ${bossTemplate.name}`,
                health: scaledHealth,
                maxHealth: scaledHealth,
                damage: scaledDamage,
                gold: scaledGold,
                exp: scaledExp
            };
        }

        function describeRoom(isMove = false) {
            const room = game.currentRoom;
            let messages = [];

            if (isMove) {
                messages.push(`You move to a new room. You are in ${room.description}`);
            } else {
                messages.push(`You are in ${room.description}`);
            }
            
            // Describe exits
            let exits = [];
            if (game.dungeon.grid[`${room.x},${room.y - 1}`]) exits.push('North');
            if (game.dungeon.grid[`${room.x},${room.y + 1}`]) exits.push('South');
            if (game.dungeon.grid[`${room.x + 1},${room.y}`]) exits.push('East');
            if (game.dungeon.grid[`${room.x - 1},${room.y}`]) exits.push('West');

            messages.push(`Exits are to the ${exits.join(', ')}.`);

            if (room.type === 'treasure' && room.loot) {
                messages.push('You see a large treasure chest!');
            } else if (room.type === 'enemy' && room.enemy && !room.cleared) {
                messages.push(`A ${room.enemy.name} attacks! Combat initiated!`);
                game.combat = { enemy: room.enemy, playerDefending: false, enemyFrozen: 0, enemyPoisoned: 0, playerStunned: false };
                messages.push(`The ${room.enemy.name} has ${room.enemy.health} health.`);
            } else if (room.type === 'boss' && room.enemy && !room.cleared) {
                messages.push(`The massive ${room.enemy.name} roars! Prepare for a difficult battle! Combat initiated!`);
                game.combat = { enemy: room.enemy, playerDefending: false, enemyFrozen: 0, enemyPoisoned: 0, playerStunned: false };
                messages.push(`The ${room.enemy.name} has ${room.enemy.health} health.`);
            } else if (room.type === 'stairs') {
                messages.push('You see the stairs descending to the next dungeon level.');
            } else if (room.type === 'trap' && !room.cleared) {
                 messages.push('Be cautious! You feel a sudden draft and hear a click. This room might be trapped.');
            } else if (room.type === 'crypt' && !room.cleared) {
                messages.push('There might be some valuable ancient artifacts here.');
            } else if (room.type === 'fountain') {
                messages.push('The magical water seems inviting. You could drink or rest here.');
            }

            speakSequence(messages, () => {
                if (game.combat) {
                    // Start combat loop automatically after initial description
                    if (game.combat.enemy.health > 0) {
                        speak('Say attack, defend, special, cast spell, use potion, or flee.');
                    }
                }
            });
        }

        function move(direction) {
            if (game.combat) {
                speak('You must deal with the enemy first! Say flee to attempt an escape.');
                return;
            }

            let newX = game.player.position.x;
            let newY = game.player.position.y;
            
            if (direction === 'north') newY--;
            else if (direction === 'south') newY++;
            else if (direction === 'east') newX++;
            else if (direction === 'west') newX--;

            const key = `${newX},${newY}`;
            const newRoom = game.dungeon.grid[key];

            if (newRoom) {
                game.player.position.x = newX;
                game.player.position.y = newY;
                game.currentRoom = newRoom;
                game.currentRoom.visited = true;

                if (game.currentRoom.type === 'trap' && !game.currentRoom.cleared) {
                    const damage = game.currentRoom.trapDamage;
                    game.player.health -= damage;
                    game.currentRoom.cleared = true; 
                    
                    let trapMessages = [
                        `You fell into a hidden pit!`,
                        `A dart shoots out and strikes you!`,
                        `The floor gives way to poisoned spikes!`
                    ];
                    
                    speak(randomItem(trapMessages) + ` You take ${damage} damage.`, () => {
                        if (game.player.health <= 0) {
                            endGame(false);
                        } else {
                            describeRoom(true);
                        }
                    });
                } else if (game.currentRoom.type === 'enemy' && game.currentRoom.enemy && !game.currentRoom.cleared) {
                     describeRoom(true);
                } else if (game.currentRoom.type === 'boss' && game.currentRoom.enemy && !game.currentRoom.cleared) {
                     describeRoom(true);
                }
                else {
                    describeRoom(true);
                }
            } else {
                speak("A solid stone wall blocks your path. You can't go that way.");
            }
        }

                function playerAttack() {
            if (!game.combat) { speak('You can only attack during combat.'); return; }
            if (game.combat.playerStunned) {
                game.combat.playerStunned = false;
                enemyTurn('You are stunned and cannot act this turn!', true);
                return;
            }
            
            const damage = getPlayerDamage() + rollDice(5); // Small randomness
            
            game.combat.enemy.health -= damage;
            
            let messages = [`You strike the ${game.combat.enemy.name} for ${damage} damage!`];
            
            if (game.combat.enemy.health <= 0) {
                endCombat(messages);
            } else {
                messages.push(`The ${game.combat.enemy.name} has ${game.combat.enemy.health} health remaining.`);
                enemyTurn(messages);
            }
        }

        function playerDefend() {
            if (!game.combat) { speak('You can only defend during combat.'); return; }
            if (game.combat.playerStunned) {
                game.combat.playerStunned = false;
                enemyTurn('You are stunned and cannot act this turn!', true);
                return;
            }

            game.combat.playerDefending = true;
            enemyTurn('You brace yourself for the next attack, increasing your defense.', false);
        }
        
        function playerSpecial() {
            if (!game.combat) { speak('You can only use a special ability during combat.'); return; }
            if (game.combat.playerStunned) {
                game.combat.playerStunned = false;
                enemyTurn('You are stunned and cannot act this turn!', true);
                return;
            }

            const ability = classes[game.player.class].special;
            
            if (game.player.mana < ability.cost) {
                speak(`You do not have enough mana. ${ability.name} costs ${ability.cost} mana.`);
                return;
            }
            
            game.player.mana -= ability.cost;
            
            let messages = [`You use ${ability.name}!`];

            if (ability.type === 'damage') {
                game.combat.enemy.health -= ability.damage;
                messages.push(`It deals ${ability.damage} damage!`);
            }
            
            if (game.combat.enemy.health <= 0) {
                endCombat(messages);
            } else {
                messages.push(`The ${game.combat.enemy.name} has ${game.combat.enemy.health} health remaining.`);
                enemyTurn(messages);
            }
        }
        
        function castSpell(command) {
            if (!game.combat) { speak('You can only cast spells in combat.'); return; }
            if (game.combat.playerStunned) {
                game.combat.playerStunned = false;
                enemyTurn('You are stunned and cannot act this turn!', true);
                return;
            }

            // Find ability by keyword
            const targetAbility = abilities.find(a => command.includes(a.name.toLowerCase()));
            
            if (!targetAbility) {
                 const mageAbilities = abilities.filter(a => a.class === 'mage').map(a => a.name).join(', ');
                 speak(`What spell? Your known spells are: ${mageAbilities}.`);
                 return;
            }
            
            if (game.player.mana < targetAbility.cost) {
                speak(`You do not have enough mana. ${targetAbility.name} costs ${targetAbility.cost} mana.`);
                return;
            }
            
            game.player.mana -= targetAbility.cost;
            let messages = [`You cast ${targetAbility.name}!`];
            
            // Handle effects
            game.combat.enemy.health -= targetAbility.damage;
            messages.push(`It deals ${targetAbility.damage} damage.`);

            if (targetAbility.type === 'freeze') {
                game.combat.enemyFrozen = 1; 
                messages.push(`The ${game.combat.enemy.name} is frozen for one turn!`);
            } else if (targetAbility.type === 'stun') {
                game.combat.playerStunned = true; // Stun applies to the enemy, not player
                messages.push(`The ${game.combat.enemy.name} is stunned for one turn!`);
            } else if (targetAbility.type === 'poison') {
                game.combat.enemyPoisoned = targetAbility.duration;
                messages.push(`The ${game.combat.enemy.name} is poisoned for ${targetAbility.duration} turns!`);
            }

            if (game.combat.enemy.health <= 0) {
                endCombat(messages);
            } else {
                messages.push(`The ${game.combat.enemy.name} has ${game.combat.enemy.health} health remaining.`);
                enemyTurn(messages);
            }
        }

        function enemyTurn(playerMessages, skipTurn = false) {
            
            let combat = game.combat;
            let enemy = combat.enemy;
            let messages = Array.isArray(playerMessages) ? playerMessages : [playerMessages];
            
            // Handle enemy poison/freeze effects before its action
            if (combat.enemyFrozen > 0) {
                messages.push(`The ${enemy.name} is frozen and cannot move!`);
                combat.enemyFrozen--;
                skipTurn = true;
            }

            if (combat.enemyPoisoned > 0) {
                const poisonDamage = 5;
                enemy.health -= poisonDamage;
                messages.push(`Poison deals ${poisonDamage} damage to the ${enemy.name}.`);
                combat.enemyPoisoned--;
                if (enemy.health <= 0) {
                    endCombat(messages);
                    return;
                }
            }

            if (skipTurn) {
                speakSequence(messages, () => {
                    if (enemy.health > 0) speak('Say attack, defend, special, cast spell, use potion, or flee.');
                });
                game.combat.playerDefending = false;
                return;
            }
            
            if (enemy.health > 0) {
                let damage = enemy.damage + rollDice(3);
                let defense = getPlayerDefense();
                
                if (combat.playerDefending) {
                    defense *= 2; 
                }
                
                let actualDamage = Math.max(0, damage - defense);
                
                game.player.health -= actualDamage;
                
                messages.push(`The ${enemy.name} hits you for ${actualDamage} damage.`);
                
                game.combat.playerDefending = false; // Defense lasts one turn

                if (game.player.health <= 0) {
                    endGame(messages);
                } else {
                    messages.push(`Your health is now ${game.player.health} of ${game.player.maxHealth}. Say your next command.`);
                    speakSequence(messages);
                }
            } else {
                // If enemy was killed by poison, endCombat already handled it.
            }
        }

        function attemptFlee() {
            if (!game.combat) { speak('You are not in combat.'); return; }
            if (game.combat.playerStunned) {
                game.combat.playerStunned = false;
                enemyTurn('You are stunned and cannot flee!', true);
                return;
            }

            const successChance = game.combat.enemy.fleeChance;
            
            if (Math.random() < successChance) {
                let messages = [`You successfully flee the battle!`];
                game.combat = null; 
                game.phase = 'exploration';
                
                if (game.player.markedFleeRoom) {
                    // Move to marked room
                    game.player.position.x = game.player.markedFleeRoom.x;
                    game.player.position.y = game.player.markedFleeRoom.y;
                    const key = `${game.player.markedFleeRoom.x},${game.player.markedFleeRoom.y}`;
                    game.currentRoom = game.dungeon.grid[key];
                    messages.push(`You retreat to your marked room.`);
                    describeRoom(messages);
                } else {
                    // Move to the start room
                    game.player.position = { x: Math.floor(game.dungeon.size / 2), y: Math.floor(game.dungeon.size / 2) };
                    const key = `${game.player.position.x},${game.player.position.y}`;
                    game.currentRoom = game.dungeon.grid[key];
                    messages.push(`You retreat to the dungeon entrance.`);
                    describeRoom(messages);
                }
            } else {
                // Failed to flee, enemy attacks
                enemyTurn(`You failed to flee! The ${game.combat.enemy.name} attacks!`);
            }
        }

        function endCombat(playerMessages) {
            let enemy = game.combat.enemy;
            let messages = Array.isArray(playerMessages) ? playerMessages : [playerMessages];
            
            messages.push(`You defeated the ${enemy.name}! You gained ${enemy.gold} gold and ${enemy.exp} experience.`);
            game.player.gold += enemy.gold;
            gainExperience(enemy.exp);

            game.currentRoom.cleared = true; 
            game.currentRoom.enemy = null;
            game.combat = null;
            game.phase = 'exploration';
            
            speakSequence(messages, () => {
                describeRoom();
            });
        }
        
        function processPotionCommand(command) {
            const potionName = command.includes('mana') ? 'Mana Potion' : 'Health Potion';
            const potionIndex = game.player.inventory.indexOf(potionName);
            
            if (potionIndex === -1) {
                speak(`You do not have a ${potionName} in your inventory.`);
                return;
            }

            game.player.inventory.splice(potionIndex, 1);
            
            if (potionName === 'Health Potion') {
                const healAmount = 50;
                const actualHeal = Math.min(healAmount, game.player.maxHealth - game.player.health);
                game.player.health = Math.min(game.player.health + healAmount, game.player.maxHealth);
                speak(`You drink the Health Potion and heal ${actualHeal} health. Your health is now ${game.player.health}/${game.player.maxHealth}.`, () => {
                    if (game.combat) enemyTurn('The enemy is waiting for your next action.');
                });
            } else if (potionName === 'Mana Potion') {
                const restoreAmount = 50;
                const actualRestore = Math.min(restoreAmount, game.player.maxMana - game.player.mana);
                game.player.mana = Math.min(game.player.mana + restoreAmount, game.player.maxMana);
                speak(`You drink the Mana Potion and restore ${actualRestore} mana. Your mana is now ${game.player.mana}/${game.player.maxMana}.`, () => {
                    if (game.combat) enemyTurn('The enemy is waiting for your next action.');
                });
            }
        }

        function searchRoom() {
            if (game.currentRoom.loot) {
                game.player.inventory.push(game.currentRoom.loot.name);
                game.player.gold += game.currentRoom.loot.value;
                speak(`You search the room and find ${game.currentRoom.loot.name} and ${game.currentRoom.loot.value} gold! The ${game.currentRoom.loot.name} is added to your inventory.`, () => {
                    game.currentRoom.loot = null;
                    game.currentRoom.cleared = true;
                    describeRoom();
                });
            } else if (game.currentRoom.type === 'crypt' && !game.currentRoom.cleared) {
                const lootChance = rollDice(100);
                if (lootChance <= 30) {
                    const item = randomItem([...rings, ...amulets]);
                    
                    // Always equip/discover rings/amulets as the scaled object
                    const scaledItem = getAccessoryData(item.name, true);
                    game.player.inventory.push(scaledItem);
                    speak(`You rummage through an ancient coffin and find an **${scaledItem.scaledName}**! It's added to your inventory.`, () => {
                        game.currentRoom.cleared = true;
                    });
                } else {
                    speak('You search the crypt but only find dust and old bones.');
                    game.currentRoom.cleared = true;
                }
            } else if (game.currentRoom.type === 'empty' && !game.currentRoom.cleared && rollDice(10) === 1) {
                 const goldFound = rollDice(10) * game.dungeon.currentLevel;
                 game.player.gold += goldFound;
                 speak(`You search under a loose floorboard and find a small stash of ${goldFound} gold!`);
                 game.currentRoom.cleared = true;
            } else {
                speak('You search the room thoroughly, but find nothing of interest.');
            }
        }

        function openChest() {
            if (game.currentRoom.type !== 'treasure') {
                speak('There is no treasure chest here.');
                return;
            }
            if (!game.currentRoom.loot) {
                 speak('The chest is already empty.');
                 return;
            }
            
            let messages = [];
            let gold = rollDice(50) + (game.dungeon.currentLevel * 20);
            game.player.gold += gold;
            messages.push(`You open the chest and find ${gold} gold!`);
            
            // Add a potion
            const potionType = rollDice(2) === 1 ? 'Health Potion' : 'Mana Potion';
            game.player.inventory.push(potionType);
            messages.push(`You also find a ${potionType}.`);
            
            // 20% chance for a ring or amulet
            if (rollDice(100) <= 20) {
                const accessory = rollDice(2) === 1 ? randomItem(rings) : randomItem(amulets);
                const scaledAccessory = getAccessoryData(accessory.name, true);
                game.player.inventory.push(scaledAccessory);
                messages.push(`You find a valuable **${scaledAccessory.scaledName}**!`);
            }
            
            game.currentRoom.loot = null; 
            game.currentRoom.cleared = true;
            
            speakSequence(messages);
        }
        
        function equipItem(command) {
            const classType = game.player.class;
            
            // Find base name from inventory
            const targetName = game.player.inventory.find(item => 
                command.toLowerCase().includes(item.toLowerCase())
            );

            if (!targetName) {
                speak('You do not have that item to equip. Try listing your inventory.');
                return;
            }
            
            // Check for weapons, armor, or shields
            let itemData;
            let itemType;

            itemData = equipment.weapons.find(w => w.name === targetName && w.class === classType);
            if (itemData) itemType = 'weapon';

            if (!itemData) {
                itemData = equipment.armor.find(a => a.name === targetName && a.class === classType);
                if (itemData) itemType = 'armor';
            }

            if (!itemData) {
                itemData = equipment.shields.find(s => s.name === targetName && s.class === classType);
                if (itemData) itemType = 'shield';
            }
            
            if (!itemData) {
                speak(`${targetName} is not a valid piece of equipment for your ${classes[classType].name} class.`);
                return;
            }

            // Unequip old item and put into inventory
            let oldItem = game.player[itemType];
            if (oldItem) {
                game.player.inventory.push(oldItem);
            }
            
            // Equip new item
            game.player[itemType] = targetName;
            
            // Remove from inventory
            const index = game.player.inventory.indexOf(targetName);
            game.player.inventory.splice(index, 1);
            
            speak(`You equip the ${targetName}. ${oldItem ? `Your ${oldItem} is put in your inventory.` : ''}`);
        }

        function readBook(command) {
            const bookName = command.includes('icy blast') ? 'Icy Blast' :
                             command.includes('shield bash') ? 'Shield Bash' :
                             command.includes('poison blade') ? 'Poison Blade' : null;
                             
            if (!bookName) {
                const availableBooks = game.player.inventory.filter(i => abilities.some(a => a.name === i));
                if (availableBooks.length > 0) {
                    speak(`You have scrolls for: ${availableBooks.join(', ')}. Say "read" followed by the spell name.`);
                } else {
                    speak('You have no scrolls or tomes to read.');
                }
                return;
            }
            
            const abilityData = abilities.find(a => a.name === bookName);
            const bookIndex = game.player.inventory.indexOf(bookName);

            if (bookIndex === -1) {
                speak(`You don't have the scroll for ${bookName}.`);
                return;
            }
            
            if (abilityData.class !== game.player.class) {
                speak(`You are a ${classes[game.player.class].name}. You cannot learn the ${abilityData.class}'s ability: ${bookName}.`);
                return;
            }

            if (game.player.learnedAbilities.includes(bookName)) {
                speak(`You have already mastered ${bookName}.`);
                return;
            }

            // Learn ability and consume item
            game.player.learnedAbilities.push(bookName);
            game.player.inventory.splice(bookIndex, 1);

            speak(`You read the scroll and learn ${bookName}: ${abilityData.description}. It costs ${abilityData.cost} mana.`, () => {
                listInventory();
            });
        }

        function useLockpicks() {
            if (game.currentRoom.type !== 'treasure') {
                speak('There is nothing to lockpick here.');
                return;
            }
            
            const lockpicksIndex = game.player.inventory.indexOf('Lockpicks');
            
            if (lockpicksIndex === -1) {
                speak('You need Lockpicks to attempt opening a locked chest.');
                return;
            }
            
            // In a real game, this would be a check, but for simplicity:
            openChest();
            
            // Remove lockpicks after use
            game.player.inventory.splice(lockpicksIndex, 1);
        }

        function meditate() {
            if (game.combat) {
                speak('You cannot safely meditate in combat.');
                return;
            }
            
            const healthRestore = Math.floor(game.player.maxHealth * 0.1);
            const manaRestore = Math.floor(game.player.maxMana * 0.2);
            
            game.player.health = Math.min(game.player.health + healthRestore, game.player.maxHealth);
            game.player.mana = Math.min(game.player.mana + manaRestore, game.player.maxMana);
            
            speak(`You meditate for a while, restoring ${healthRestore} health and ${manaRestore} mana.`, () => {
                characterStatus();
            });
        }
        
        function useFountain() {
            if (game.currentRoom.type !== 'fountain') {
                speak('There is no magical fountain here.');
                return;
            }
            
            // Full heal
            game.player.health = game.player.maxHealth;
            game.player.mana = game.player.maxMana;
            game.currentRoom.cleared = true; 
            
            speak('You drink from the enchanted fountain. You feel completely refreshed and restored!', () => {
                characterStatus();
            });
        }
        
        function useStairs() {
            if (game.currentRoom.type !== 'stairs') {
                speak('There are no stairs leading down in this room.');
                return;
            }
            
            game.dungeon.currentLevel++;
            game.player.health = game.player.maxHealth; // Full heal between levels
            game.player.mana = game.player.maxMana; // Full mana between levels
            
            speak(`You descend the stairs to Dungeon Level ${game.dungeon.currentLevel}. Your health and mana are fully restored.`, () => {
                generateDungeon();
                describeRoom();
            });
        }

        function characterStatus() {
            const damage = getPlayerDamage();
            const defense = getPlayerDefense();
            
            let messages = [
                `You are a Level ${game.player.level} ${classes[game.player.class].name}.`,
                `Health: ${game.player.health}/${game.player.maxHealth}. Mana: ${game.player.mana}/${game.player.maxMana}.`,
                `Experience: ${game.player.experience}/${game.player.experienceToNext}.`,
                `Gold: ${game.player.gold}.`,
                `Weapon: ${game.player.weapon}. Armor: ${game.player.armor}. Shield: ${game.player.shield || 'None'}.`,
                `Total Attack: ${damage}. Total Defense: ${defense}.`
            ];
            
            const ringNames = game.player.equippedRings.map(r => r.scaledName).join(', ');
            if (ringNames.length > 0) messages.push(`Equipped Rings: ${ringNames}.`);

            const amuletName = game.player.equippedAmulet ? game.player.equippedAmulet.scaledName : 'None';
            messages.push(`Equipped Amulet: ${amuletName}.`);
            
            speakSequence(messages);
        }

        function listInventory() {
            if (game.player.inventory.length === 0) {
                speak('Your inventory is empty.');
                return;
            }
            
            // Format accessory objects for speech
            const formattedInventory = game.player.inventory.map(item => {
                return typeof item === 'object' ? item.scaledName : item;
            });

            speak(`You have: ${formattedInventory.join(', ')}. Say "use potion", "equip [item name]", or "read [scroll name]".`);
        }

        function listCommands() {
            let messages = [
                'In Exploration Mode, say a direction: north, south, east, or west.',
                'Say look or search to examine your surroundings.',
                'Say status or inventory to check your stats and gear.',
                'Say use potion, equip [item], or read [scroll].',
                'Say meditate to restore some health and mana.',
                'Say save game to get a load PIN.',
                'Say mark room to set a flee point.'
            ];
            
            if (game.combat) {
                messages = [
                    'In Combat Mode, say attack to strike with your weapon.',
                    'Say defend to brace for the next hit.',
                    'Say special to use your class ability.',
                    'Say cast [spell name] for mage abilities.',
                    'Say use potion to heal or restore mana.',
                    'Say flee to attempt an escape.'
                ];
            }
            speakSequence(messages);
        }

        function giveHint() {
            if (game.needsClass) {
                speak('Say warrior, mage, or rogue to start your adventure.');
                return;
            }

            if (game.combat) {
                speak('You must defeat the enemy! Use attack to deal damage, defend to reduce incoming damage, or use your special ability.');
                return;
            }
            
            // Default exploration hint
            speak('Try moving in a direction (north, south, east, west) or searching the room for treasure.');
        }

        function showHelp() {
            speak('Welcome to Echo Dungeon Enhanced! You control the hero using voice commands. Say "commands" to hear the list of options.');
        }

        function endGame(messages, win = false) {
            speechSynthesis.cancel();
            game.started = false;
            game.combat = null;
            game.phase = 'end';
            micButton.classList.add('start-button');
            
            let finalMessage = win ? 'Congratulations! You have cleared the dungeon! The echo fades as you escape with your treasure.' :
                                     'Your health reached zero. You have been defeated. The sounds of the dungeon fade into silence.';

            if (messages) {
                speakSequence(Array.isArray(messages) ? messages : [messages, finalMessage], () => {
                    initializeGame(); // Restart logic
                });
            } else {
                speak(finalMessage, () => {
                    initializeGame(); // Restart logic
                });
            }
        }

        checkBrowserSupport();
        if (!game.initialized) {
            micButton.innerHTML = 'Tap to Start';
        }

    </script>
</body>
</html>




