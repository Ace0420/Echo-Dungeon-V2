<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Echo Dungeon Enhanced V2</title>
<style>
body {
margin: 0;
padding: 0;
background: #111;
font-family: monospace;
color: #eee;
}
#micButton {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background: #222;
border: none;
cursor: pointer;
transition: background 0.3s;
z-index: 10;
}
#micButton.active {
background: #444;
}
.listening {
background: #004400 !important;
}
.start-button {
background: #000044 !important;
}
#textDisplay {
position: absolute;
width: 1px;
height: 1px;
padding: 0;
margin: -1px;
overflow: hidden;
clip: rect(0,0,0,0);
white-space: nowrap;
border: 0;
}
#statusLog {
position: fixed;
bottom: 0;
left: 0;
width: 100%;
background: rgba(0,0,0,0.8);
padding: 10px;
font-size: 12px;
max-height: 200px;
overflow-y: auto;
display: none;
z-index: 5;
}
footer {
position: fixed;
bottom: 220px;
right: 10px;
font-size: 10px;
color: #666;
}
</style>
</head>
<body>
<div id="textDisplay" role="status" aria-live="polite"></div>
<div id="statusLog"></div>
<button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button - Tap to speak"></button>
<footer>Made with ❤️ for smiles. Free & open-source.</footer>
<script>
const micButton = document.getElementById('micButton');
const textDisplay = document.getElementById('textDisplay');
const statusLog = document.getElementById('statusLog');
function displayText(text) {
textDisplay.innerHTML = text;
const log = statusLog.querySelector('p') || document.createElement('p');
log.innerHTML += `<br>${new Date().toLocaleTimeString()}: ${text}`;
statusLog.appendChild(log);
if (statusLog.style.display !== 'block') statusLog.scrollTop = statusLog.scrollHeight;
}
function toggleStatus() {
statusLog.style.display = statusLog.style.display === 'block' ? 'none' : 'block';
}
let browserSupport = {
speechSynthesis: false,
speechRecognition: false,
https: false
};
function checkBrowserSupport() {
browserSupport.https = window.location.protocol === 'https:' || window.location.hostname === 'localhost';
browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
}
const game = {
player: {
class: "",
level: 1,
experience: 0,
experienceToNext: 100,
health: 100,
maxHealth: 100,
mana: 50,
maxMana: 50,
gold: 25,
inventory: [],
equippedRings: [],
learnedAbilities: [],
equippedAmulet: "",
position: {x: 5, y: 5},
baseAttack: 15,
defense: 0,
weapon: "",
armor: ""
},
dungeon: {
grid: {},
size: 10,
secretRoom: null,
hasSecretRoom: false,
currentLevel: 1
},
currentRoom: null,
combat: null,
listening: false,
started: false,
needsClass: true,
initialized: false,
phase: 'init'
};
const classes = {
warrior: {
name: 'Warrior',
health: 120,
maxHealth: 120,
mana: 30,
maxMana: 30,
gold: 50,
items: ['Steel Sword', 'Health Potion', 'Chainmail'],
special: {name: 'Power Strike', damage: 40, cost: 15, type: 'damage'}
},
mage: {
name: 'Mage',
health: 80,
maxHealth: 80,
mana: 100,
maxMana: 100,
gold: 75,
items: ['Mystic Staff', 'Mana Potion', 'Health Potion', 'Enchanted Robes'],
special: {name: 'Fireball', damage: 30, cost: 20, type: 'damage'}
},
rogue: {
name: 'Rogue',
health: 100,
maxHealth: 100,
mana: 60,
maxMana: 60,
gold: 100,
items: ['Shadow Daggers', 'Lockpicks', 'Health Potion', 'Shadow Leather'],
special: {name: 'Backstab', damage: 35, cost: 25, type: 'damage'}
}
};
const equipment = {
weapons: [
{name: 'Steel Sword', attack: 8, class: 'warrior', value: 100},
{name: 'Mystic Staff', attack: 10, class: 'mage', value: 150},
{name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120}
],
armor: [
{name: 'Chainmail', defense: 8, class: 'warrior', value: 100},
{name: 'Enchanted Robes', defense: 5, class: 'mage', value: 120},
{name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110}
]
};
const abilities = [
{name: 'Heal', damage: 0, healing: 40, cost: 25, type: 'heal', description: 'Restore 40 health using mana', class: 'mage'},
{name: 'Shield Bash', damage: 30, cost: 20, type: 'stun', description: 'Stun enemy for one turn', class: 'warrior'},
{name: 'Poison Blade', damage: 20, cost: 20, type: 'poison', duration: 3, description: 'Poison damages 5 per turn for 3 turns', class: 'rogue'}
];
const amulets = [
{name: 'Amulet of Vitality', effect: '+15 Max Health', stat: 'maxHealth', value: 15},
{name: 'Amulet of Mana', effect: '+15 Max Mana', stat: 'maxMana', value: 15},
{name: 'Amulet of Experience', effect: '+20% Experience Gain', stat: 'expGain', value: 1.2}
];
const books = [
{name: 'Spellbook of Heal', ability: abilities.find(a => a.name === 'Heal'), class: 'mage'},
{name: 'Tome of Shield Bash', ability: abilities.find(a => a.name === 'Shield Bash'), class: 'warrior'},
{name: 'Grimoire of Poison', ability: abilities.find(a => a.name === 'Poison Blade'), class: 'rogue'}
];
const roomTypes = {
entrance: {
descriptions: [
'the grand entrance hall. Torches flicker on ancient stone walls.',
'the entrance chamber. A faded tapestry hangs on the north wall.',
'the starting hall. Cobwebs drape from vaulted ceilings above.'
],
hasEnemy: false
},
empty: {
descriptions: [
'an abandoned barracks. Rusty weapons litter the floor.',
'a collapsed library. Torn pages scatter at your feet.',
'a crumbling shrine. A broken altar stands in the center.',
'a forgotten armory. Empty weapon racks line the walls.',
'a dusty workshop. Ancient tools hang from hooks.',
'a meditation chamber. Stone benches circle a dry fountain.',
'an old prison cell. Iron bars have rusted through.',
'a guard post. A skeleton sits slumped in a chair.'
],
hasEnemy: false
},
treasure: {
descriptions: [
'a glittering treasure vault. Gold coins reflect torchlight.',
'a dragon\'s hoard chamber. Piles of jewels gleam in the darkness.',
'a royal treasury. Ancient chests overflow with riches.',
'a pirate\'s cache. Stolen goods fill every corner.',
'a wizard\'s vault. Magical artifacts pulse with energy.'
],
hasEnemy: false
},
enemy: {
descriptions: [
'a dark chamber. You sense hostile eyes watching you.',
'a blood-stained arena. Old battle scars mark the floor.',
'a shadowy lair. Something growls in the darkness.',
'a monster\'s den. Bones crunch beneath your feet.',
'a cursed chamber. An evil presence fills the air.'
],
hasEnemy: true
},
boss: {
descriptions: [
'the throne room of darkness. A massive beast awaits on a stone throne.',
'the dragon\'s lair. Heat radiates from its scales, filling the air with sulfurous smoke.'
],
hasEnemy: true
}
};
    // Enhanced functions
function handleFoundItem(item) {
  if (books.some(b => b.name === item)) {
    const book = books.find(b => b.name === item);
    if (game.player.class.toLowerCase() === book.class) {
      if (!game.player.learnedAbilities.some(a => a.name === book.ability.name)) {
        game.player.learnedAbilities.push(book.ability);
        displayText(`You pore over the ${item} and learn ${book.ability.name}! Your mind expands with new arcane knowledge.`);
        speak(`Learned ${book.ability.name}!`);
      } else {
        displayText(`The ${item} holds no new secrets for you—your knowledge is already complete.`);
      }
    } else {
      displayText(`The ${item} is beyond your understanding. It crumbles to dust.`);
    }
    return;
  }
  // Equipment/Amulet handling
  const equip = [...equipment.weapons, ...equipment.armor, ...amulets].find(e => e.name === item);
  if (equip) {
    game.player.inventory.push(item);
    if (equip.stat) { // Amulet
      game.player[equip.stat] += equip.value;
      if (equip.stat === 'maxHealth') game.player.health += equip.value;
      if (equip.stat === 'maxMana') game.player.mana += equip.value;
      displayText(`Equipped ${item}: ${equip.effect}`);
    } else {
      displayText(`Acquired ${item}. Say "equip ${item}" to use it.`);
    }
    return;
  }
  // Potions/Gold fallback
  if (item.includes('Gold')) {
    const goldAmt = parseInt(item.match(/\d+/)[0]);
    game.player.gold += goldAmt;
    displayText(`Found ${goldAmt} gold! Total: ${game.player.gold}.`);
  } else if (item.includes('Health Potion') && game.player.health < game.player.maxHealth) {
    const healAmount = 40;
    game.player.health = Math.min(game.player.health + healAmount, game.player.maxHealth);
    displayText(`Quaffed ${item}, health restored to ${game.player.health}/${game.player.maxHealth}.`);
  } else if (item.includes('Health Potion')) {
    displayText(`Health potion found, but you're at full health. Added to inventory.`);
    game.player.inventory.push(item);
  } else {
    game.player.inventory.push(item);
    displayText(`Picked up ${item}.`);
  }
}
function generateRoom() {
  const typeKeys = Object.keys(roomTypes);
  const randomType = typeKeys[Math.floor(Math.random() * typeKeys.length)];
  const room = {
    type: randomType,
    description: roomTypes[randomType].descriptions[Math.floor(Math.random() * roomTypes[randomType].descriptions.length)],
    hasEnemy: roomTypes[randomType].hasEnemy,
    loot: null,
    enemy: null
  };
  // Loot chances
  if (!room.hasEnemy) {
    if (Math.random() < 0.1) { // Book
      const availableBooks = books.filter(b => b.class === game.player.class.toLowerCase());
      room.loot = availableBooks.length > 0 ? availableBooks[Math.floor(Math.random() * availableBooks.length)].name : 'Health Potion';
    } else if (Math.random() < 0.3) { // General loot
      const loots = ['Health Potion', 'Gold (50)', ...amulets.map(a => a.name), ...equipment.weapons.map(w => w.name), ...equipment.armor.map(ar => ar.name)];
      room.loot = loots[Math.floor(Math.random() * loots.length)];
    }
  }
  if (room.loot) handleFoundItem(room.loot);
  if (room.hasEnemy) {
    room.enemy = {name: 'Goblin', health: 50, attack: 10}; // Simple enemy
    game.combat = {enemy: room.enemy, turn: 'player'};
    displayText(`${room.description} A ${room.enemy.name} attacks! Say "attack" to fight.`);
    // Auto-resolve stub for now
    const playerDmg = game.player.baseAttack + Math.floor(Math.random() * 10);
    room.enemy.health -= playerDmg;
    if (room.enemy.health <= 0) {
      displayText(`You defeat the ${room.enemy.name}! +50 XP, +20 gold.`);
      game.player.experience += 50;
      game.player.gold += 20;
      game.combat = null;
      checkLevelUp();
    }
  } else {
    displayText(room.description);
  }
  game.currentRoom = room;
  updateStatus();
}
function checkLevelUp() {
  if (game.player.experience >= game.player.experienceToNext) {
    game.player.level++;
    game.player.experience -= game.player.experienceToNext;
    game.player.experienceToNext = Math.floor(game.player.experienceToNext * 1.5);
    game.player.maxHealth += 10;
    game.player.health = game.player.maxHealth;
    displayText(`Level up! Now level ${game.player.level}. Health boosted!`);
    speak(`Level up to ${game.player.level}!`);
  }
}
function updateStatus() {
  const status = `Lvl ${game.player.level} | HP ${game.player.health}/${game.player.maxHealth} | Mana ${game.player.mana}/${game.player.maxMana} | Gold ${game.player.gold} | Abilities: ${game.player.learnedAbilities.map(a => a.name).join(', ') || 'None'}`;
  // Could add to log here if expanded
}
function speak(text) {
  if (browserSupport.speechSynthesis) {
    const utterance = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(utterance);
  }
}
function saveGame() {
  localStorage.setItem('echoDungeonSave', JSON.stringify(game));
  displayText('Game saved!');
}
function loadGame() {
  const saved = localStorage.getItem('echoDungeonSave');
  if (saved) {
    Object.assign(game, JSON.parse(saved));
    displayText('Game loaded! Welcome back.');
    updateStatus();
  } else {
    displayText('No save found.');
  }
}
// Voice handling
function handleClick() {
  if (!game.started) {
    checkBrowserSupport();
    if (!browserSupport.https || !browserSupport.speechRecognition) {
      displayText('Voice requires HTTPS/localhost. Starting text mode—say commands mentally or imagine them!');
      initGame();
      return;
    }
    micButton.classList.remove('start-button');
    micButton.classList.add('listening');
    displayText('Tap to speak your class: Warrior, Mage, or Rogue.');
    startListening();
  } else {
    startListening();
  }
}
let recognition;
function startListening() {
  game.listening = true;
  micButton.classList.add('active');
  if (browserSupport.speechRecognition) {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-US';
    recognition.onresult = (event) => {
      const command = event.results[0][0].transcript.toLowerCase().trim();
      processCommand(command);
    };
    recognition.onerror = (event) => {
      displayText('Voice error: ' + event.error);
      stopListening();
    };
    recognition.onend = () => stopListening();
    recognition.start();
  }
}
function stopListening() {
  game.listening = false;
  micButton.classList.remove('active');
  if (recognition) recognition.stop();
}
function processCommand(command) {
  if (game.needsClass) {
    const selectedClass = Object.keys(classes).find(key => command.includes(key));
    if (selectedClass) {
      initPlayer(selectedClass);
      game.needsClass = false;
      game.started = true;
      displayText(`Welcome, ${classes[selectedClass].name}! Say "explore" to delve deeper. "Status" for readout, "save/load" for progress.`);
      speak(`Welcome, ${classes[selectedClass].name}. Adventure awaits!`);
    } else {
      displayText('Try: Warrior, Mage, or Rogue.');
    }
    return;
  }
  if (command.includes('explore')) {
    generateRoom();
  } else if (command.includes('status')) {
    toggleStatus();
    displayText('Status log toggled.');
  } else if (command.includes('heal') && game.player.learnedAbilities.some(a => a.name === 'Heal')) {
    const heal = game.player.learnedAbilities.find(a => a.name === 'Heal');
    if (game.player.mana >= heal.cost) {
      game.player.mana -= heal.cost;
      game.player.health = Math.min(game.player.health + heal.healing, game.player.maxHealth);
      displayText(`Healed ${heal.healing} HP. Mana: ${game.player.mana}/${game.player.maxMana}.`);
    } else {
      displayText('Insufficient mana.');
    }
  } else if (command.includes('attack') && game.combat) {
    // Expand combat if needed
    displayText('Attack landed! Enemy defeated. (Full combat coming soon.)');
    game.combat = null;
  } else if (command.includes('equip') && command.includes(' ')) {
    const itemName = command.split('equip ')[1];
    const item = game.player.inventory.find(i => i.toLowerCase().includes(itemName.toLowerCase()));
    if (item) {
      // Stub: Assume auto-equip if class matches
      displayText(`${item} equipped!`);
      game.player.inventory = game.player.inventory.filter(i => i !== item);
    } else {
      displayText('Item not found in inventory.');
    }
  } else if (command.includes('save')) {
    saveGame();
  } else if (command.includes('load')) {
    loadGame();
  } else {
    displayText('Commands: explore, status, heal (if learned), attack (in combat), equip [item], save/load.');
  }
  if (game.started) updateStatus();
}
function initPlayer(classKey) {
  const cls = classes[classKey];
  game.player.class = cls.name;
  game.player.maxHealth = cls.maxHealth;
  game.player.health = cls.health;
  game.player.maxMana = cls.maxMana;
  game.player.mana = cls.mana;
  game.player.gold += cls.gold;
  cls.items.forEach(item => handleFoundItem(item));
  game.player.learnedAbilities.push(cls.special);
  displayText(`You are a ${cls.name}. HP: ${game.player.health} | Mana: ${game.player.mana} | Gold: ${game.player.gold} | Starting gear equipped.`);
  updateStatus();
}
function initGame() {
  checkBrowserSupport();
  displayText('Echo Dungeon Enhanced V2. Speak your class to begin: Warrior, Mage, or Rogue. Or imagine the adventure!');
  game.initialized = true;
}
// Auto-init if no voice
if (!browserSupport.speechRecognition) {
  initGame();
}
</script>
</body>
</html>
